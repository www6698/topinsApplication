<?xml version="1.0"?>
<doc>
    <assembly>
        "ArenaNET"
    </assembly>
    <members>
        <member name="T:ArenaNET.EBayerAlgorithm">
            <summary>
Represents the different algorithms available to interpolate Bayer image data.
</summary>
        </member>
        <member name="F:ArenaNET.EBayerAlgorithm._UndefinedAlgorithm">
            <summary>
Undefined algorithm
</summary>
        </member>
        <member name="F:ArenaNET.EBayerAlgorithm.AdaptiveHomogeneityDirected">
            <summary>
Adaptive algorithm that uses directional data (slower, more accurate coloring)
</summary>
        </member>
        <member name="F:ArenaNET.EBayerAlgorithm.DirectionalInterpolation">
            <summary>
Algorithm that averages nearest neighbors (faster)
</summary>
        </member>
        <member name="T:ArenaNET.EPixelEndianness">
            <summary>
Represents the different pixel endiannesses.
</summary>
        </member>
        <member name="F:ArenaNET.EPixelEndianness.Big">
            <summary>
Big endian
</summary>
        </member>
        <member name="F:ArenaNET.EPixelEndianness.Little">
            <summary>
Little endian
</summary>
        </member>
        <member name="F:ArenaNET.EPixelEndianness.Unknown">
            <summary>
Unknown pixel endianness
</summary>
        </member>
        <member name="T:ArenaNET.EPfncFormat">
            <summary>
Represents the possible pixel formats of an image, as defined by the PFNC
(Pixel Format Naming Convention).
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.InvalidPixelFormat">
            <summary>
Invalid pixel format
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.LucidXYTP128f">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB16_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB12_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB10_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB8_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG16_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG12_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG10_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG8_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR16_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR12_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR10_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR8_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG16_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG12_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG10_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG8_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono16_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono12_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono10_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono8_4ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB16_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB12_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB10_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB8_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG16_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG12_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG10_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG8_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR16_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR12_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR10_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR8_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG16_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG12_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG10_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG8_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono16_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono12_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono10_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono8_2ch">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr24_CbYCr">
            <summary>
yuv-490, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr16_CbYCr">
            <summary>
yuv-490, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAolp_BayerRG12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolp_BayerRG12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAolp_BayerRG12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_S3_BayerRG12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAngles_0d_45d_90d_135d_BayerRG12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_CY8">
            <summary>
3d, 16-to-8-bit, non-unique-identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABCY8">
            <summary>
3d, 16-to-8-bit, non-unique-identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAolp_Mono12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolp_Mono12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAolp_Mono12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_S3_Mono12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAngles_0d_45d_90d_135d_Mono12">
            <summary>
polar, unpacked, non-unique identifier
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGB8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerBG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerGR8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadBayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QuadMono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGB8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerBG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerGR8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualBayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono10Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono10p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono10">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.DualMono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_YCbCr8_CbYCr">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_YCbCr8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_BGR8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_RGB8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_BayerBG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_BayerGB8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_BayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_BayerGR8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.QOI_Mono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_CY16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_C16Y8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAngle_BayerRG16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAngle_BayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAngle_BayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAngle_Mono16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAngle_Mono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAngle_Mono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr411_24_CbYYCrYY">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr411_16_CbYYCrYY">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_24_CbYCrY">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_16_CbYCrY">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.BGR24">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.RGB24">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG24">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB24">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG24">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR24">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.Mono24">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAolp_BayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAolp_BayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolp_BayerRG16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolp_BayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolp_BayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAolp_BayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAolp_BayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_S3_BayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_S3_BayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_BayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_BayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAngles_0d_45d_90d_135d_BayerRG12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAngles_0d_45d_90d_135d_BayerRG8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABCY16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_C16s">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC16s">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABCY16s">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAolp_Mono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolpAolp_Mono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolp_Mono16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolp_Mono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedDolp_Mono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAolp_Mono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAolp_Mono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_S3_Mono16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_S3_Mono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_S3_Mono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_Mono16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_Mono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedStokes_S0_S1_S2_Mono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAngles_0d_45d_90d_135d_Mono16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAngles_0d_45d_90d_135d_Mono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizedAngles_0d_45d_90d_135d_Mono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizeMono16">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizeMono12">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizeMono12Packed">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizeMono12p">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.PolarizeMono8">
            <summary />
        </member>
        <member name="F:&lt;unknown type&gt;.RGB12V1Packed">
            <summary>
GigE Vision specific format, Red-Green-Blue 12-bit packed - variant 1
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB10V1Packed">
            <summary>
GigE Vision specific format, Red-Green-Blue 10-bit packed - variant 1
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG12Packed">
            <summary>
GigE Vision specific format, Bayer Red-Green 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG10Packed">
            <summary>
GigE Vision specific format, Bayer Red-Green 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR12Packed">
            <summary>
GigE Vision specific format, Bayer Green-Red 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR10Packed">
            <summary>
GigE Vision specific format, Bayer Green-Red 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB12Packed">
            <summary>
GigE Vision specific format, Bayer Green-Blue 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB10Packed">
            <summary>
GigE Vision specific format, Bayer Green-Blue 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG12Packed">
            <summary>
GigE Vision specific format, Bayer Blue-Green 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG10Packed">
            <summary>
GigE Vision specific format, Bayer Blue-Green 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono12Packed">
            <summary>
GigE Vision specific format, Monochrome 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono10Packed">
            <summary>
GigE Vision specific format, Monochrome 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YUV422_8_UYVY">
            <summary>
YUV 4:2:2 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YUV422_8">
            <summary>
YUV 4:2:2 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YUV411_8_UYYVYY">
            <summary>
YUV 4:1:1 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YUV8_UYV">
            <summary>
YUV 4:4:4 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_12p_CbYCrY">
            <summary>
YCbCr 4:2:2 12-bit packed BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_12p">
            <summary>
YCbCr 4:2:2 12-bit packed BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_12_CbYCrY">
            <summary>
YCbCr 4:2:2 12-bit unpacked BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_12">
            <summary>
YCbCr 4:2:2 12-bit unpacked BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_10p_CbYCrY">
            <summary>
YCbCr 4:2:2 10-bit packed BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_10p">
            <summary>
YCbCr 4:2:2 10-bit packed BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_10_CbYCrY">
            <summary>
YCbCr 4:2:2 10-bit unpacked BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_10">
            <summary>
YCbCr 4:2:2 10-bit unpacked BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_8_CbYCrY">
            <summary>
YCbCr 4:2:2 8-bit BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_422_8">
            <summary>
YCbCr 4:2:2 8-bit BT.2020 
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_411_8_CbYYCrYY">
            <summary>
YCbCr 4:1:1 8-bit BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_12p_CbYCr">
            <summary>
YCbCr 4:4:4 12-bit packed BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_12_CbYCr">
            <summary>
YCbCr 4:4:4 12-bit unpacked BT.2020 
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_10p_CbYCr">
            <summary>
YCbCr 4:4:4 10-bit packed BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_10_CbYCr">
            <summary>
YCbCr 4:4:4 10-bit unpacked BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr2020_8_CbYCr">
            <summary>
YCbCr 4:4:4 8-bit BT.2020
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_12p_CbYCrY">
            <summary>
YCbCr 4:2:2 12-bit packed BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_12p">
            <summary>
YCbCr 4:2:2 12-bit packed BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_12_CbYCrY">
            <summary>
YCbCr 4:2:2 12-bit unpacked BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_12">
            <summary>
YCbCr 4:2:2 12-bit unpacked BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_10p_CbYCrY">
            <summary>
YCbCr 4:2:2 10-bit packed BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_10p">
            <summary>
YCbCr 4:2:2 10-bit packed BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_10_CbYCrY">
            <summary>
YCbCr 4:2:2 10-bit unpacked BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_10">
            <summary>
YCbCr 4:2:2 10-bit unpacked BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_8_CbYCrY">
            <summary>
YCbCr 4:2:2 8-bit BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_422_8">
            <summary>
YCbCr 4:2:2 8-bit BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_411_8_CbYYCrYY">
            <summary>
YCbCr 4:1:1 8-bit BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_12p_CbYCr">
            <summary>
YCbCr 4:4:4 12-bit packed BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_12_CbYCr">
            <summary>
YCbCr 4:4:4 12-bit unpacked BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_10p_CbYCr">
            <summary>
YCbCr 4:4:4 10-bit packed BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_10_CbYCr">
            <summary>
YCbCr 4:4:4 10-bit unpacked BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr709_8_CbYCr">
            <summary>
YCbCr 4:4:4 8-bit BT.709
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_12p_CbYCrY">
            <summary>
YCbCr 4:2:2 12-bit packed BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_12p">
            <summary>
YCbCr 4:2:2 12-bit packed BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_12_CbYCrY">
            <summary>
YCbCr 4:2:2 12-bit unpacked BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_12">
            <summary>
YCbCr 4:2:2 12-bit unpacked BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_10p_CbYCrY">
            <summary>
YCbCr 4:2:2 10-bit packed BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_10p">
            <summary>
YCbCr 4:2:2 10-bit packed BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_10_CbYCrY">
            <summary>
YCbCr 4:2:2 10-bit unpacked BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_10">
            <summary>
YCbCr 4:2:2 10-bit unpacked BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_8_CbYCrY">
            <summary>
YCbCr 4:2:2 8-bit BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_422_8">
            <summary>
YCbCr 4:2:2 8-bit BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_411_8_CbYYCrYY">
            <summary>
YCbCr 4:1:1 8-bit BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_12p_CbYCr">
            <summary>
YCbCr 4:4:4 12-bit packed BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_12_CbYCr">
            <summary>
YCbCr 4:4:4 12-bit unpacked BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_10p_CbYCr">
            <summary>
YCbCr 4:4:4 10-bit packed BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_10_CbYCr">
            <summary>
YCbCr 4:4:4 10-bit unpacked BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr601_8_CbYCr">
            <summary>
YCbCr 4:4:4 8-bit BT.601
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_12p_CbYCrY">
            <summary>
YCbCr 4:2:2 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_12p">
            <summary>
YCbCr 4:2:2 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_12_CbYCrY">
            <summary>
YCbCr 4:2:2 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_12">
            <summary>
YCbCr 4:2:2 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_10p_CbYCrY">
            <summary>
YCbCr 4:2:2 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_10p">
            <summary>
YCbCr 4:2:2 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_10_CbYCrY">
            <summary>
YCbCr 4:2:2 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_10">
            <summary>
YCbCr 4:2:2 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_8_CbYCrY">
            <summary>
YCbCr 4:2:2 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr422_8">
            <summary>
YCbCr 4:2:2 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr411_8_CbYYCrYY">
            <summary>
YCbCr 4:1:1 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr411_8">
            <summary>
YCbCr 4:1:1 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr12p_CbYCr">
            <summary>
YCbCr 4:4:4 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr12_CbYCr">
            <summary>
YCbCr 4:4:4 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr10p_CbYCr">
            <summary>
YCbCr 4:4:4 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr10_CbYCr">
            <summary>
YCbCr 4:4:4 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr8_CbYCr">
            <summary>
YCbCr 4:4:4 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.YCbCr8">
            <summary>
YCbCr 4:4:4 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WRWG16">
            <summary>
Sparse Color Filter #1 White-Red-White-Green 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WRWG14">
            <summary>
Sparse Color Filter #1 White-Red-White-Green 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WRWG12p">
            <summary>
Sparse Color Filter #1 White-Red-White-Green 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WRWG12">
            <summary>
Sparse Color Filter #1 White-Red-White-Green 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WRWG10p">
            <summary>
Sparse Color Filter #1 White-Red-White-Green 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WRWG10">
            <summary>
Sparse Color Filter #1 White-Red-White-Green 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WRWG8">
            <summary>
Sparse Color Filter #1 White-Red-White-Green 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWR16">
            <summary>
Sparse Color Filter #1 White-Green-White-Red 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWR14">
            <summary>
Sparse Color Filter #1 White-Green-White-Red 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWR12p">
            <summary>
Sparse Color Filter #1 White-Green-White-Red 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWR12">
            <summary>
Sparse Color Filter #1 White-Green-White-Red 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWR10p">
            <summary>
Sparse Color Filter #1 White-Green-White-Red 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWR10">
            <summary>
Sparse Color Filter #1 White-Green-White-Red 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWR8">
            <summary>
Sparse Color Filter #1 White-Green-White-Red 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWB16">
            <summary>
Sparse Color Filter #1 White-Green-White-Blue 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWB14">
            <summary>
Sparse Color Filter #1 White-Green-White-Blue 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWB12p">
            <summary>
Sparse Color Filter #1 White-Green-White-Blue 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWB12">
            <summary>
Sparse Color Filter #1 White-Green-White-Blue 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWB10p">
            <summary>
Sparse Color Filter #1 White-Green-White-Blue 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWB10">
            <summary>
Sparse Color Filter #1 White-Green-White-Blue 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WGWB8">
            <summary>
Sparse Color Filter #1 White-Green-White-Blue 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WBWG16">
            <summary>
Sparse Color Filter #1 White-Blue-White-Green 16-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WBWG14">
            <summary>
Sparse Color Filter #1 White-Blue-White-Green 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WBWG12p">
            <summary>
Sparse Color Filter #1 White-Blue-White-Green 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WBWG12">
            <summary>
Sparse Color Filter #1 White-Blue-White-Green 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WBWG10p">
            <summary>
Sparse Color Filter #1 White-Blue-White-Green 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WBWG10">
            <summary>
Sparse Color Filter #1 White-Blue-White-Green 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.SCF1WBWG8">
            <summary>
Sparse Color Filter #1 White-Blue-White-Green 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorRGBG12p">
            <summary>
Bi-color Red/Green - Blue/Green 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorRGBG12">
            <summary>
Bi-color Red/Green - Blue/Green 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorRGBG10p">
            <summary>
Bi-color Red/Green - Blue/Green 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorRGBG10">
            <summary>
Bi-color Red/Green - Blue/Green 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorRGBG8">
            <summary>
Bi-color Red/Green - Blue/Green 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorBGRG12p">
            <summary>
Bi-color Blue/Green - Red/Green 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorBGRG12">
            <summary>
Bi-color Blue/Green - Red/Green 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorBGRG10p">
            <summary>
Bi-color Blue/Green - Red/Green 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorBGRG10">
            <summary>
Bi-color Blue/Green - Red/Green 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BiColorBGRG8">
            <summary>
Bi-color Blue/Green - Red/Green 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Confidence32f">
            <summary>
Confidence 32-bit floating point
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Confidence16">
            <summary>
Confidence 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Confidence8">
            <summary>
Confidence 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Confidence1p">
            <summary>
Confidence 1-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Confidence1">
            <summary>
Confidence 1-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_C32f">
            <summary>
3D coordinate C 32-bit floating point
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_C16">
            <summary>
3D coordinate C 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_C12p">
            <summary>
3D coordinate C 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_C10p">
            <summary>
3D coordinate C 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_C8">
            <summary>
3D coordinate C 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_B32f">
            <summary>
3D coordinate B 32-bit floating point
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_B16">
            <summary>
3D coordinate B 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_B12p">
            <summary>
3D coordinate B 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_B10p">
            <summary>
3D coordinate B 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_B8">
            <summary>
3D coordinate B 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_A32f">
            <summary>
3D coordinate A 32-bit floating point
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_A16">
            <summary>
3D coordinate A 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_A12p">
            <summary>
3D coordinate A 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_A10p">
            <summary>
3D coordinate A 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_A8">
            <summary>
3D coordinate A 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC32f_Planar">
            <summary>
3D coordinate A-C 32-bit floating point planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC32f">
            <summary>
3D coordinate A-C 32-bit floating point
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC16_Planar">
            <summary>
3D coordinate A-C 16-bit planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC16">
            <summary>
3D coordinate A-C 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC12p_Planar">
            <summary>
3D coordinate A-C 12-bit packed planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC12p">
            <summary>
3D coordinate A-C 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC10p_Planar">
            <summary>
3D coordinate A-C 10-bit packed planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC10p">
            <summary>
3D coordinate A-C 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC8_Planar">
            <summary>
3D coordinate A-C 8-bit planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_AC8">
            <summary>
3D coordinate A-C 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC32f_Planar">
            <summary>
3D coordinate A-B-C 32-bit floating point planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC32f">
            <summary>
3D coordinate A-B-C 32-bit floating point
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC16_Planar">
            <summary>
3D coordinate A-B-C 16-bit planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC16">
            <summary>
3D coordinate A-B-C 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC12p_Planar">
            <summary>
3D coordinate A-B-C 12-bit packed planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC12p">
            <summary>
3D coordinate A-B-C 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC10p_Planar">
            <summary>
3D coordinate A-B-C 10-bit packed planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC10p">
            <summary>
3D coordinate A-B-C 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC8_Planar">
            <summary>
3D coordinate A-B-C 8-bit planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Coord3D_ABC8">
            <summary>
3D coordinate A-B-C 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.B16">
            <summary>
Blue 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.B12">
            <summary>
Blue 12-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.B10">
            <summary>
Blue 10-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.B8">
            <summary>
Blue 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.G16">
            <summary>
Green 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.G12">
            <summary>
Green 12-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.G10">
            <summary>
Green 10-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.G8">
            <summary>
Green 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.R16">
            <summary>
Red 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.R12">
            <summary>
Red 12-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.R10">
            <summary>
Red 10-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.R8">
            <summary>
Red 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGR565p">
            <summary>
Blue-Green-Red 5/6/5-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGR16">
            <summary>
Blue-Green-Red 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGR14">
            <summary>
Blue-Green-Red 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGR12p">
            <summary>
Blue-Green-Red 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGR12">
            <summary>
Blue-Green-Red 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGR10p">
            <summary>
Blue-Green-Red 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGR10">
            <summary>
Blue-Green-Red 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGR8">
            <summary>
Blue-Green-Red 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGRa16">
            <summary>
Blue-Green-Red-alpha 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGRa14">
            <summary>
Blue-Green-Red-alpha 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGRa12p">
            <summary>
Blue-Green-Red-alpha 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGRa12">
            <summary>
Blue-Green-Red-alpha 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGRa10p">
            <summary>
Blue-Green-Red-alpha 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGRa10">
            <summary>
Blue-Green-Red-alpha 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BGRa8">
            <summary>
Blue-Green-Red-alpha 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB565p">
            <summary>
Red-Green-Blue 5/6/5-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB16_Planar">
            <summary>
Red-Green-Blue 16-bit planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB16">
            <summary>
Red-Green-Blue 16-bit  
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB14">
            <summary>
Red-Green-Blue 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB12p">
            <summary>
Red-Green-Blue 12-bit packed  
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB12_Planar">
            <summary>
Red-Green-Blue 12-bit unpacked planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB12">
            <summary>
Red-Green-Blue 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB10p32">
            <summary>
Red-Green-Blue 10-bit packed into 32-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB10p">
            <summary>
Red-Green-Blue 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB10_Planar">
            <summary>
Red-Green-Blue 10-bit unpacked planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB10">
            <summary>
Red-Green-Blue 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB8_Planar">
            <summary>
Red-Green-Blue 8-bit planar
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGB8">
            <summary>
Red-Green-Blue 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGBa16">
            <summary>
Red-Green-Blue-alpha 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGBa14">
            <summary>
Red-Green-Blue-alpha 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGBa12p">
            <summary>
Red-Green-Blue-alpha 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGBa12">
            <summary>
Red-Green-Blue-alpha 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGBa10p">
            <summary>
Red-Green-Blue-alpha 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGBa10">
            <summary>
Red-Green-Blue-alpha 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.RGBa8">
            <summary>
Red-Green-Blue-alpha 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG16">
            <summary>
Bayer Red-Green 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG12p">
            <summary>
Bayer Red-Green 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG12">
            <summary>
Bayer Red-Green 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG10p">
            <summary>
Bayer Red-Green 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG10">
            <summary>
Bayer Red-Green 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerRG8">
            <summary>
Bayer Red-Green 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR16">
            <summary>
Bayer Green-Red 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR12p">
            <summary>
Bayer Green-Red 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR12">
            <summary>
Bayer Green-Red 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR10p">
            <summary>
Bayer Green-Red 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR10">
            <summary>
Bayer Green-Red 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGR8">
            <summary>
Bayer Green-Red 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB16">
            <summary>
Bayer Green-Blue 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB12p">
            <summary>
Bayer Green-Blue 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB12">
            <summary>
Bayer Green-Blue 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB10p">
            <summary>
Bayer Green-Blue 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB10">
            <summary>
Bayer Green-Blue 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerGB8">
            <summary>
Bayer Green-Blue 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG16">
            <summary>
Bayer Blue-Green 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG12p">
            <summary>
Bayer Blue-Green 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG12">
            <summary>
Bayer Blue-Green 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG10p">
            <summary>
Bayer Blue-Green 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG10">
            <summary>
Bayer Blue-Green 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.BayerBG8">
            <summary>
Bayer Blue-Green 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono16">
            <summary>
Monochrome 16-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono14">
            <summary>
Monochrome 14-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono12p">
            <summary>
Monochrome 12-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono12">
            <summary>
Monochrome 12-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono10p">
            <summary>
Monochrome 10-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono10">
            <summary>
Monochrome 10-bit unpacked
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono8s">
            <summary>
Monochrome 8-bit signed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono8">
            <summary>
Monochrome 8-bit
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono4p">
            <summary>
Monochrome 4-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono2p">
            <summary>
Monochrome 2-bit packed
</summary>
        </member>
        <member name="F:&lt;unknown type&gt;.Mono1p">
            <summary>
Monochrome 1-bit packed
</summary>
        </member>
        <member name="T:ArenaNET.EBufferPayloadType">
            <summary>
Represents the different payload types of a buffer.
</summary>
        </member>
        <member name="F:ArenaNET.EBufferPayloadType.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.EBufferPayloadType.CompressedImageExtendedChunk">
            <summary>
Compressed image data extended with chunk data
</summary>
        </member>
        <member name="F:ArenaNET.EBufferPayloadType.CompressedImage">
            <summary>
Compressed image data only
</summary>
        </member>
        <member name="F:ArenaNET.EBufferPayloadType.ChunkData">
            <summary>
Chunk data only; image data may be present as chunk
</summary>
        </member>
        <member name="F:ArenaNET.EBufferPayloadType.ImageExtendedChunk">
            <summary>
Image data extended with chunk data
</summary>
        </member>
        <member name="F:ArenaNET.EBufferPayloadType.Image">
            <summary>
Image data only
</summary>
        </member>
        <member name="T:ArenaNET.EDisplayNotation">
            <summary>
Represents the best way to display a float node.
</summary>
        </member>
        <member name="F:ArenaNET.EDisplayNotation.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.EDisplayNotation.fnScientific">
            <summary>
The notation is scientific (e.g. 1.234e2)
</summary>
        </member>
        <member name="F:ArenaNET.EDisplayNotation.fnFixed">
            <summary>
The notation is fixed (e.g. 123.4)
</summary>
        </member>
        <member name="F:ArenaNET.EDisplayNotation.fnAutomatic">
            <summary>
The notation if either scientific or fixed depending on which is shorter
</summary>
        </member>
        <member name="T:ArenaNET.ERepresentation">
            <summary>
Integer representation of the increment mode enum (EIncMode).
</summary>
        </member>
        <member name="F:ArenaNET.ERepresentation.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.ERepresentation.MACAddress">
            <summary>
MAC address
</summary>
        </member>
        <member name="F:ArenaNET.ERepresentation.IPV4Address">
            <summary>
IP address
</summary>
        </member>
        <member name="F:ArenaNET.ERepresentation.HexNumber">
            <summary>
Hex number in an edit control
</summary>
        </member>
        <member name="F:ArenaNET.ERepresentation.PureNumber">
            <summary>
Decimal number in an edit control
</summary>
        </member>
        <member name="F:ArenaNET.ERepresentation.Boolean">
            <summary>
Check box
</summary>
        </member>
        <member name="F:ArenaNET.ERepresentation.Logarithmic">
            <summary>
Slider with logarithmic behavior
</summary>
        </member>
        <member name="F:ArenaNET.ERepresentation.Linear">
            <summary>
Slider with linear behavior
</summary>
        </member>
        <member name="T:ArenaNET.EIncMode">
            <summary>
Represents the different increment modes of an integer/float node.
</summary>
        </member>
        <member name="F:ArenaNET.EIncMode.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.EIncMode.listIncrement">
            <summary>
The feature has a list of valid values
</summary>
        </member>
        <member name="F:ArenaNET.EIncMode.fixedIncrement">
            <summary>
The feature has a fixed increment
</summary>
        </member>
        <member name="F:ArenaNET.EIncMode.noIncrement">
            <summary>
The feature has no increment
</summary>
        </member>
        <member name="T:ArenaNET.EInterfaceType">
            <summary>
Represents the interface types of a node.
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIPort">
            <summary>
IPort interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIEnumEntry">
            <summary>
IEnumEntry interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIEnumeration">
            <summary>
IEnumeration interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfICategory">
            <summary>
ICategory interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIRegister">
            <summary>
IRegister interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIString">
            <summary>
IString interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIFloat">
            <summary>
IFloat interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfICommand">
            <summary>
ICommand interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIBoolean">
            <summary>
IBoolean interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIInteger">
            <summary>
IInteger interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIBase">
            <summary>
IBase interface
</summary>
        </member>
        <member name="F:ArenaNET.EInterfaceType.intfIValue">
            <summary>
IValue interface
</summary>
        </member>
        <member name="T:ArenaNET.ELinkType">
            <summary>
Represents various subsets of related child nodes.
</summary>
        </member>
        <member name="F:ArenaNET.ELinkType.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.ELinkType.ctTerminalNodes">
            <summary>
All indirectly connected terminal nodes
</summary>
        </member>
        <member name="F:ArenaNET.ELinkType.ctDependingNodes">
            <summary>
All directly or indirectly connected nodes which are invalidated by this node (i.e. which are dependent on this node)
</summary>
        </member>
        <member name="F:ArenaNET.ELinkType.ctInvalidatingChildren">
            <summary>
All directly connected nodes which invalidate this node
</summary>
        </member>
        <member name="F:ArenaNET.ELinkType.ctWritingChildren">
            <summary>
All nodes which can write a value further down the node stack
</summary>
        </member>
        <member name="F:ArenaNET.ELinkType.ctReadingChildren">
            <summary>
All nodes which can be read from
</summary>
        </member>
        <member name="F:ArenaNET.ELinkType.ctParentNodes">
            <summary>
All nodes for which this node is at least an invalidating child
</summary>
        </member>
        <member name="T:ArenaNET.ECachingMode">
            <summary>
Represents the different caching modes a node might use.
</summary>
        </member>
        <member name="F:ArenaNET.ECachingMode.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.ECachingMode.WriteAround">
            <summary>
Write to register, write to cache on read
</summary>
        </member>
        <member name="F:ArenaNET.ECachingMode.WriteThrough">
            <summary>
Write to cache and register
</summary>
        </member>
        <member name="F:ArenaNET.ECachingMode.NoCache">
            <summary>
Do not use cache
</summary>
        </member>
        <member name="T:ArenaNET.EYesNo">
            <summary>
Represents 'Yes' and 'No'.
</summary>
        </member>
        <member name="F:ArenaNET.EYesNo.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.EYesNo.No">
            <summary>
No
</summary>
        </member>
        <member name="F:ArenaNET.EYesNo.Yes">
            <summary>
Yes
</summary>
        </member>
        <member name="T:ArenaNET.EVisibility">
            <summary>
Represents the different visibilities of a node.
</summary>
        </member>
        <member name="F:ArenaNET.EVisibility.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.EVisibility.Invisible">
            <summary>
Not visible
</summary>
        </member>
        <member name="F:ArenaNET.EVisibility.Guru">
            <summary>
Visible for gurus
</summary>
        </member>
        <member name="F:ArenaNET.EVisibility.Expert">
            <summary>
Visible for experts or gurus
</summary>
        </member>
        <member name="F:ArenaNET.EVisibility.Beginner">
            <summary>
Always visible
</summary>
        </member>
        <member name="T:ArenaNET.ENameSpace">
            <summary>
Represents whether a node is in the standard or custom namespaces.
</summary>
        </member>
        <member name="F:ArenaNET.ENameSpace.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.ENameSpace.Standard">
            <summary>
Name resides in one of the standard namespaces
</summary>
        </member>
        <member name="F:ArenaNET.ENameSpace.Custom">
            <summary>
Name resides in custom namespace
</summary>
        </member>
        <member name="T:ArenaNET.EAccessMode">
            <summary>
Represents the different access modes for a device or its features.
</summary>
        </member>
        <member name="F:ArenaNET.EAccessMode.Unknown">
            <summary>
Undefined or unknown
</summary>
        </member>
        <member name="F:ArenaNET.EAccessMode.RW">
            <summary>
Read and write
</summary>
        </member>
        <member name="F:ArenaNET.EAccessMode.RO">
            <summary>
Read only
</summary>
        </member>
        <member name="F:ArenaNET.EAccessMode.WO">
            <summary>
Write only
</summary>
        </member>
        <member name="F:ArenaNET.EAccessMode.NA">
            <summary>
Not available
</summary>
        </member>
        <member name="F:ArenaNET.EAccessMode.NI">
            <summary>
Not implemented
</summary>
        </member>
        <member name="F:ArenaNET.Consts.INF">
            <summary>
Represents infinity
</summary>
        </member>
        <member name="T:ArenaNET.Consts">
            <summary>
Constants that can be used with various function calls
</summary>
        </member>
        <member name="M:Arena.GetBitsPerPixel(System.UInt64)">
 @fn size_t GetBitsPerPixel(uint64_t pixelFormat)

 @param pixelFormat
  - Type: uint64_t
  - Represents: PfncFormat
  - Pixel format to get bits per pixel

 @return 
  - Type: size_t
  - Number of bits per pixel for given pixel format

 <B> GetBitsPerPixel </B> gets the number of bits per pixel of the image
 from the integer value of the pixel format (PfncFormat).

 Pixel format values are determined by the PFNC (Pixel Format Naming
 Convention) specification. The PFNC assigns a name and number to each
 pixel format, helping to standardize pixel formats. The number of bits per
 pixel can be found in each integer at bytes 5 and 6 (mask 0x00FF0000). The
 pixel format can be determined by the integer using the GetPixelFormatName
 function provided by the PFNC.

</member>
        <member name="M:Arena.ImageFactory.Destroy(Arena.IImage*)">
 @fn static void Destroy(IImage* pImage)

 @param pImage
  - Type: Arena::IImage*
  - Pointer to the image to destroy
  - Image must be from image factory

 @return 
  - none

 <B> Destroy </B> cleans up an image (Arena::IImage) and deallocates
 its memory. It must be called on any image created by the image
 factory
 (Arena::ImageFactory::Create, Arena::ImageFactory::Copy,
 Arena::ImageFactory::Convert).

 All images from the image factory, whether created
 (Arena::ImageFactory::Create), copied (Arena::ImageFactory::Copy), or
 converted (Arena::ImageFactory::Convert), must be destroyed to
 deallocate their memory; otherwise, memory will leak. It is important
 that <B> Destroy </B> only be called on images from the image factory,
 and not on those retrieved from a device (Arena::IDevice).

 @warning 
  - Images from the image factory must be destroyed.
  - Images from a device should be requeued.

 @see 
  - Arena::IImage
  - Arena::IDevice
  - Arena::ImageFactory::Create
  - Arena::ImageFactory::Copy
  - Arena::ImageFactory::Convert

</member>
        <member name="M:Arena.ImageFactory.DeinterleaveChannels(Arena.IImage*)">
 @fn static IImage* DeinterleaveChannels(IImage* pImage);

 @param pImage
  - Type: Arena::IImage
  - Pointer to the image

 @return
  - Type: Arena::IImage*
  - Pointer to a processed planar image

 <B> Deinterleave Channels </B> separates interleaved channels into a planar image.

 @see
  - Arena::IImage

</member>
        <member name="M:Arena.ImageFactory.DecompressImage(Arena.ICompressedImage*)">
 @fn static void DecompressImage(ICompressedImage* pImage)

 @param pImage
  - Type: Arena::ICompressedImage*
  - Pointer to the compressed image to decompress

 @return 
  - Type: Arena::IImage*
  - Pointer to the decompressed image

 <B> DecompressImage </B> decompresses a compressed image 
 (Arena::ICompressedImage) and returns a pointer to the decompressed 
 image (Arena::IImage). In doing so, it creates a completely new image, 
 similar to a deep copy but with an uncompressed pixel format. Images created 
 with the image factory must be destroyed (Arena::ImageFactory::Destroy) 
 when no longer needed; otherwise, memory will leak.

 \code{.cpp}
 	// decompressing and destroying an image
 	{
 		Arena::IImage* pDecompressed = Arena::ImageFactory::DecompressImage(pImage);
 		// ...
 		Arena::ImageFactory::Destroy(pDecompressed);
 	}
 \endcode

 @warning 
  - Images from the image factory must be destroyed.
  - Images from a device should be requeued.

 @see 
  - Arena::ICompressedImage
  - Arena::IImage
  - Arena::ImageFactory::Destroy

</member>
        <member name="M:Arena.ImageFactory.ProcessSoftwareLUT(Arena.IImage*,System.Byte*,System.UInt64)">
 @fn static IImage* ProcessSoftwareLUT(IImage* pImage, uint8_t* pLUT, size_t len);

 @param pImage
  - Type: Arena::IImage
  - Pointer to the image

 @param pLUT
  - Type: uint8_t*
  - Pointer to the beginning of the lookup table

 @param len
  - Type: size_t
  - Length of image buffer

 @return
  - Type: Arena::IImage*
  - Pointer to a lookup table processed image  

 <B> Process Software LUT </B> runs an image through a lookup table, allowing for a redefinition of values.

 @see
  - Arena::IImage

</member>
        <member name="M:Arena.ImageFactory.SelectBits(Arena.IImage*,System.UInt64,System.Int32)">
 @fn static IImage* SelectBits(IImage* pImage, size_t numBits, int offset);

 @param pImage
  - Type: Arena::IImage
  - Pointer to the image

 @param numBits
  - Type: size_t
  - Number of bits in the resulting image

 @param offset
  - Type: int
  - Offset from the beginning of the pixel

 <B> Select Bits </B> focusses onto selected portion of bits.

 @see
  - Arena::IImage

</member>
        <member name="M:Arena.ImageFactory.Convert(Arena.IImage*,System.UInt64,Arena._EBayerAlgorithm)">
 @fn static IImage* Convert(IImage* pImage, uint64_t pixelFormat, EBayerAlgorithm bayerAlgorithm = DirectionalInterpolation)

 @param pImage
  - Type: Arena::IImage
  - Pointer to the image to convert

 @param pixelFormat
  - Type: uint64_t
  - Represents: enum PfncFormat
  - Pixel format to convert to

 @param bayerAlgorithm
  - Type: Arena::EBayerAlgorithm
  - Bayer conversion algorithm to use
  - Only applicable when converting from Bayer

 @return 
  - Type: Arena::IImage*
  - Pointer to the converted image

 <B> Convert </B> converts an image (Arena::IImage) to the selected pixel
 format. In doing so, it creates a completely new image, similar to a
 deep copy but with a different pixel format. Images created with the
 image factory must be destroyed (Arena::ImageFactory::Destroy) when no
 longer needed; otherwise, memory will leak.

 \code{.cpp}
 	// creating and destroying an image
 	{
 		Arena::IImage* pConvert = Arena::ImageFactory::Convert(pImage, BGRa8);
 		// ...
 		Arena::ImageFactory::Destroy(pConvert);
 	}
 \endcode

 The list of supported pixel formats can be found in the software node
 map
 (Arena::ISystem::GetNodeMap, 'SupportedPixelFormats'). The list of
 supported conversion pixel formats differs from a device's pixel
 formats (Arena::IDevice::GetNodeMap, 'PixelFormat'). In order for
 the conversion to succeed, both the source and destination pixel formats
 must be supported. Bayer formats are supported as source formats only.

 @warning 
  - Images from the image factory must be destroyed.
  - Images from a device should be requeued.
  - Cannot convert to Bayer formats.
  - Bayer conversion algorithm is only necessary when converting from
    Bayer formats.

 @see 
  - Arena::IImage
  - Arena::ImageFactory::Destroy
  - Arena::ImageFactory::Convert
  - Arena::ISystem::GetNodeMap
  - Arena::IDevice::GetNodeMap
  - Arena::EBayerAlgorithm

</member>
        <member name="M:Arena.ImageFactory.Copy(Arena.IImage*)">
 @fn static IImage* Copy(IImage* pBuffer)

 @param pBuffer
  - Type: Arena::IImage*
  - Pointer to the image to copy

 @return 
  - Type: Arena::IImage*
  - Pointer to a deep copy of the image

 Creates a deep copy of an image

 <B> Copy </B> creates a deep copy of an image (Arena::IImage) from
 another image. Images created with the image factory must be destroyed
 (Arena::ImageFactory::Destroy) when no longer needed.

 When copying an image, the image factory allocates memory for the new
 image. As such, images created by copying an image with the image
 factory must be destroyed; otherwise, memory will leak.

 \code{.cpp}
 	// creating and destroying an image
 	{
 		IImage* pCopy = Arena::ImageFactory::Copy(pImage);
 		// ...
 		Arena::ImageFactory::Destroy(pCopy);
 	}
 \endcode

 @warning 
  - Images from the image factory must be destroyed.
  - Images from a device should be requeued.
  - Instantiates all lazy properties of the original image.

 @see 
  - Arena::IImage
  - Arena::ImageFactory::Destroy
  - Arena::ImageFactory::Copy

</member>
        <member name="M:Arena.ImageFactory.Shallow(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
 @fn static IImage* Shallow(const uint8_t* pData, size_t dataSize, size_t width, size_t height, uint64_t pixelFormat);

 @param pData
  - Type: const uint8_t
  - Pointer to the beginning of the payload data

 @param dataSize
  - Type: size_t
  - Size of the data

 @param width
  - Type: size_t
  - Unit: pixels
  - Width of the image to create

 @param height
  - Type: size_t
  - Unit: pixels
  - Height of the image to create

 @param pixelFormat
  - Type: uint64_t
  - Represents: enum PfncFormat
  - Pixel format of the image to create

 <B> Shallow </B> creates an image using user-memory.

</member>
        <member name="M:Arena.ImageFactory.CreateCompressedImage(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt64,System.UInt64)">
 @fn static ICompressedImage* CreateCompressedImage(const uint8_t* pData, size_t dataSize, uint64_t pixelFormat)

 @param pData
  - Type: const uint8_t
  - Pointer to the beginning of the payload data

 @param dataSize
  - Type: size_t
  - Size of the data

 @param pixelFormat
  - Type: uint64_t
  - Represents: enum PfncFormat
  - Pixel format of the image to create

 @return 
  - Type: Arena::ICompressedImage*
  - Pointer to the compressed image created from the parameters

 <B> Create </B> creates a compressed image (Arena::ICompressedImage) from a minimal
 set of parameters. Images created with the image factory must be destroyed
 (Arena::ImageFactory::Destroy) when no longer needed.

 When creating an image, the image factory allocates memory for the new
 image. As such, images created by the image factory must be destroyed;
 otherwise, memory will leak.

 \code{.cpp}
 	// creating and destroying a compressed image
 	{
 		ICompressedImage* pCreate = Arena::ImageFactory::CreateCompressedImage(pData, dataSize, pixelFormat);
 		// ...
 		Arena::ImageFactory::Destroy(pCreate);
 	}
 \endcode

 @warning 
  - Images from the image factory must be destroyed.
  - Images from a device must be requeued.
  - Incorrect data size may result in application crash.

 @see 
  - Arena::ICompressedImage
  - Arena::ImageFactory::Destroy
  - Arena::ImageFactory::CreateCompressedImage

</member>
        <member name="M:Arena.ImageFactory.Create(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
 @fn static IImage* Create(const uint8_t* pData, size_t dataSize, size_t width, size_t height, uint64_t pixelFormat)

 @param pData
  - Type: const uint8_t
  - Pointer to the beginning of the payload data

 @param dataSize
  - Type: size_t
  - Size of the data

 @param width
  - Type: size_t
  - Unit: pixels
  - Width of the image to create

 @param height
  - Type: size_t
  - Unit: pixels
  - Height of the image to create

 @param pixelFormat
  - Type: uint64_t
  - Represents: enum PfncFormat
  - Pixel format of the image to create

 @return 
  - Type: Arena::IImage*
  - Pointer to the image created from the parameters

 <B> Create </B> creates an image (Arena::IImage) from a minimal set of
 parameters. Images created with the image factory must be destroyed
 (Arena::ImageFactory::Destroy) when no longer needed.

 <B> Create </B> can create images from any raw image data. It has been
 designed to be generic in order to integrate image data from a variety
 of sources.

 When creating an image, the image factory allocates memory for the new
 image. As such, images created by the image factory must be destroyed;
 otherwise, memory will leak.

 \code{.cpp}
 	// creating and destroying an image
 	{
 		IImage* pCreate = Arena::ImageFactory::Create(pData, width, height, pixelFormat);
 		// ...
 		Arena::ImageFactory::Destroy(pCreate);
 	}
 \endcode

 @warning 
  - Images from the image factory must be destroyed.
  - Images from a device must be requeued.
  - Incorrect data size may result in application crash.

 @see 
  - Arena::IImage
  - Arena::ImageFactory::Destroy
  - Arena::ImageFactory::Create

</member>
        <member name="T:Arena.ImageFactory">
 @class ImageFactory

 <B> ImageFactory </B> is a static class responsible for the creation,
 copying, conversion, and destruction of images (Arena::IImage).

 The image factory allocates and deallocates memory for its images. Memory
 is allocated when an image is created (Arena::ImageFactory::Create) or
 converted (Arena::ImageFactory::Convert). To clean up memory, all images
 created by the image factory must be destroyed.
 (Arena::ImageFactory::Destroy).

 Images from the image factory are treated noticeably differently than those
 from a device (Arena::IDevice). Retrieving an image from a device grabs a
 buffer that had its memory preallocated when the device started streaming;
 retrieving and requeuing does not allocate or deallocate memory, but
 simply moves buffers around the acquisition engine. Creating, copying, and
 converting an image with the image factory allocates and deallocates
 memory as needed. This is why images from a device must be requeued with
 (Arena::IDevice::RequeueBuffer), while images from the image factory must be
 destroyed (Arena::ImageFactory::Destroy).

 @warning 
  - Images from the image factory must be destroyed.
  - Images from a device must be requeued.
  - Initialize arena system before using the image factory.

 @see 
  - Arena::IImage
  - Arena::IDevice

</member>
        <member name="M:Arena.ICompressedImage.Dispose">
 @fn virtual ~IChunkData()

 A destructor

</member>
        <member name="M:Arena.ICompressedImage.VerifyCRC">
 @fn virtual bool VerifyCRC()

 @return 
  - Type: bool
  - True if the calculated CRC value equals the one sent from the
    device
  - Otherwise, false

 <B> VerifyCRC </B> calculates the CRC of a buffer's data and verifies
 it against the CRC value sent from the device. This helps verify that
 no data has been changed or missed during a transmission. This
 function calls a global helper function to calculate the CRC
 (Arena::CalculateCRC32).

 A CRC is performed by running a set of calculations on a dataset both
 before and after a transmission. The two calculated values are then
 compared for equality. If the values are the same, then the
 transmission is deemed successful; if different, then something in the
 transmission went wrong.

 A device can be set to send a CRC value by enabling its chunk data
 setting.

 \code{.cpp}
 	// Enable chunk data and the CRC chunk
 	{
 		GenApi::INodeMap* pNodeMap = pDevice-&gt;GetNodeMap();
 		
 		GenApi::CBooleanPtr pChunkModeActive = pNodeMap-&gt;GetNode("ChunkModeActive");
 		pChunkModeActive-&gt;SetValue(true);
 		
 		GenApi::CEnumerationPtr pChunkSelector = pNodeMap-&gt;GetNode("ChunkSelector");
 		GenApi::CEnumEntryPtr pCRC = pChunkSelector-&gt;GetEntryByname("CRC");
 		pChunkSelector-&gt;SetIntValue(pCRC-&gt;GetValue());
 		
 		GenApi::CBooleanPtr pChunkEnable = pNodeMap-&gt;GetNode("ChunkEnable");
 		pChunkEnable-&gt;SetValue(true);
 	}
 \endcode

 The data can then be checked by verifying the CRC.

 \code{.cpp}
 	// Verifying a buffer's data
 	{
 		Arena::IBuffer* pBuffer = pDevice-&gt;GetBuffer(timeout);
 		if (!pBuffer-&gt;VerifyCRC())
 		{
 			// data not complete
 		}
 	}
 \endcode

 @warning 
  - May throw GenICam::GenericException or other derived exception.
  - Throws an exception if chunk data disabled or not present, or if CRC chunk
    disabled.

 @see 
  - Arena::CalculateCRC
  - Arena::IBuffer

</member>
        <member name="M:Arena.ICompressedImage.DataLargerThanBuffer">
 @fn virtual bool DataLargerThanBuffer()

 @return 
  - Type: bool
  - True if the payload is larger than the buffer
  - Otherwise, false

 <B> DataLargerThanBuffer </B> returns whether or not a buffer's
 payload data is too large for the buffer.

 A buffer may be missing data if the buffer to hold the data is too
 small. This happens when the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer) does not match the expected data
 size ('PayloadSize'). This function will also return true when
 checking whether the data is larger than the buffer.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer

</member>
        <member name="M:Arena.ICompressedImage.IsIncomplete">
 @fn virtual bool IsIncomplete()

 @return 
  - Type: bool
  - True if the data is incomplete
  - Otherwise, false

 <B> IsIncomplete </B> returns whether or not a buffer's payload data
 is complete.

 Error handling may be required if the data is
 incomplete. An incomplete image signifies that the data size
 (Arena::IBuffer::GetSizeFilled) does not match the expected data size
 ('PayloadSize'). This is either due to missed packets or a small buffer.

 The number of missed packets may be discovered through the stream node
 map
 (Arena::IDevice::GetTLStreamNodeMap). The missed packet count feature
 ('StreamMissedPacketCount') is a cumulative count of all missed packets,
 and does not necessarily reflect the number of missed packets for any
 given buffer.

 A buffer may be missing data if the buffer to hold the data is too
 small. This happens when the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer) does not match the expected data
 size ('PayloadSize'). This function will also return true when
 checking whether the data is larger than the buffer
 (Arena::IBuffer::DataLargerThanBuffer).

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeFilled
  - Arena::IDevice::GetTLStreamNodeMap
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IBuffer::DataLargerThanBuffer

</member>
        <member name="M:Arena.ICompressedImage.AsChunkData">
 @fn virtual IChunkData* AsChunkData()

 @return 
  - Type: Arena::IChunkData*
  - Pointer to the original object cast to chunk data
  - Null on failure

 <B> AsChunkData </B> casts the buffer to a chunk data
 (Arena::IChunkData). This is only possible if the payload contains
 chunk data.

 @warning 
  - Causes undefined behavior if buffer requeued.

 @see 
  - Arena::IChunkData

</member>
        <member name="M:Arena.ICompressedImage.HasChunkData">
 @fn virtual bool HasChunkData()

 @return 
  - True if the payload has chunk data
  - Otherwise, false

 <B> HasChunkData </B> returns whether or not a buffer's payload may be
 interpreted as chunk data. Calling <B> HasChunkData </B> from chunk
 data returns true.

 <B> HasChunkData </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeChunkData
  - Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk

 It returns false if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeImage

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.ICompressedImage.HasImageData">
 @fn virtual bool HasImageData()

 @return 
  - Type: bool
  - True if the payload has image data
  - False if the payload has image data packaged as chunk
  - Otherwise, false

 <B> HasImageData </B> returns whether or not a buffer's payload may be
 interpreted as image data.

 <B> HasImageData </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeImage
  - Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk

 It returns false if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeChunkData

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.ICompressedImage.GetPayloadType">
 @fn virtual size_t GetPayloadType()

 @return 
  - Type: size_t
  - Represents: enum Arena::EBufferPayloadType
  - Type of payload data

 <B> GetPayloadType </B> returns a buffer's payload type
 (Arena::EBufferPayloadType), as defined in the GigE Vision specification.

 The payload type indicates how to interpret the data stored in the
 buffer.
 (Arena::IBuffer::GetData). LUCID devices may provide three ways to
 interpret the data:
  - As an image (Arena::EBufferPayloadType::BufferPayloadTypeImage)
  - As an image with chunk data appended to the end
    (Arena::EBufferPayloadType::BufferPayloadTypeImageExtended) 
  - As chunk data, which may or may not include image data as a chunk
  - (Arena::EBufferPayloadType::BufferPayloadTypeChunkData)

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetData
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.ICompressedImage.GetFrameId">
 @fn virtual uint64_t GetFrameId()

 @return 
  - Type: uint64_t
  - Frame ID

 <B> GetFrameId </B> returns the frame ID, a sequential identifier for
 buffers.

 Frame IDs start at '1' and continue until 2^64-1
 (64-bit), at which point they roll over back to '1'. The frame ID should
 never be '0'.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

</member>
        <member name="M:Arena.ICompressedImage.GetSizeOfBuffer">
 @fn virtual size_t GetSizeOfBuffer()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the buffer

 <B> GetSizeOfBuffer </B> retrieves the size of the buffer.

 The size filled is often same as the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer), but not because they are one and the
 same. <B> GetSizeFilled </B> returns the number of bytes received
 whereas <B> GetSizeOfBuffer </B> returns the size of the buffer, which
 can either be allocated by the user or calculated by Arena
 (Arena::IDevice::GetNodeMap, 'PayloadSize').

 The payload size is calculated at the beginning of the stream and
 cannot be recalculated until the stream has stopped. Because of this,
 features that can affect payload size ('Width', 'Height',
 'PixelFormat') become unwritable when the stream has started.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.ICompressedImage.GetPayloadSize">
 @fn virtual size_t GetPayloadSize()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the intended payload

 <B> GetPayloadSize </B> retrieves the intended size of the payload.
 This is similar to the retrieved payload size
 (Arena::IBuffer::GetSizeFilled), but different in that missed data is
 included. This returns the same as the SFNC feature by the same name
 ('PayloadSize').

 @warning 
  - Causes undefined behavior if buffer requeued.

 @see 
  - Arena::IBuffer::GetSizeFilled

</member>
        <member name="M:Arena.ICompressedImage.GetSizeFilled">
 @fn virtual size_t GetSizeFilled()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the compressed data of the payload

 A getter for the size of the compressed data

 <B> GetSizeFilled </B> retrieves the size of the data of a buffer,
 excluding transport layer protocol leaders. It takes no inputs and
 returns the size of the data as output.

 The return value of <B> GetSizeFilled </B> should always be the same
 as the return value of <B> GetSizeOfBuffer </B>
 (Arena::IBuffer::GetSizeOfBuffer), but not because they are one and the
 same. <B> GetSizeFilled </B> returns the size of the data whereas <B>
 GetSizeOfBuffer </B> returns the size of the buffer, which is set
 according to the expected payload size ('PayloadSize').

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer

</member>
        <member name="M:Arena.ICompressedImage.GetData">
 @fn virtual const uint8_t* GetData()

 @return 
  - Type: const uint8_t*
  - Pointer to the beginning of the payload data

 <B> GetData </B> retrieves a pointer to the buffer's payload data.
 This data may include compressed image data (along with its own header), 
 chunk data, or both.

 To check the type of data returned, compressed image
 (Arena::IBuffer::HasImageData) and chunk data
 (Arena::IBuffer::HasChunkData) can be checked for specifically, or the
 payload type (Arena::EBufferPayloadType) can be retrieved.

 The returned data only includes payload data, not transport layer
 protocol leaders, which is handled internally. The pointer can be used
 in conjunction with size getters (Arena::IBuffer::GetSizeFilled) to
 read, process, and pass the compressed data around.

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::HasImageData
  - Arena::IBuffer::HasChunkData
  - Arena::IBuffer::GetSizeFilled
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.ICompressedImage.GetTimestampNs">
 @fn virtual uint64_t GetTimestampNs()

 @return 
  - Type: uint64_t
  - Unit: nanoseconds
  - Timestamp of the image in nanoseconds

 <B> GetTimestampNs </B> gets the timestamp of the compressed image in
 nanoseconds. Images are self-describing, so the device does not need to
 be queried to get this information.

 Compressed images are retrieved from a device (Arena::IDevice). If the 
 image was retrieved from a device, the timestamp is populated by the
 acquisition engine payload leader. The device itself is not queried
 as this data is present in the image data.

 This is the same as the general timestamp call
 (Arena::ICompressedImage::GetTimestamp).

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ICompressedImage::GetTimestamp

</member>
        <member name="M:Arena.ICompressedImage.GetTimestamp">
 @fn virtual uint64_t GetTimestamp()

 @return 
  - Type: uint64_t
  - Unit: nanoseconds
  - Timestamp of the image in nanoseconds

 <B> GetTimestamp </B> gets the timestamp of the compressed image in
 nanoseconds. Images are self-describing, so the device does not need to
 be queried to get this information.

 Compressed images are retrieved from a device (Arena::IDevice). If the 
 image was retrieved from a device, the timestamp is populated by the
 acquisition engine payload leader. The device itself is not queried
 as this data is present in the image data.

 This is the same as the nanosecond timestamp call
 (Arena::ICompressedImage::GetTimestampNs).

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ICompressedImage::GetTimestampNs

</member>
        <member name="M:Arena.ICompressedImage.GetPixelFormat">
 @fn virtual uint64_t GetPixelFormat()

 @return 
  - Type: uint64_t
  - Represents: enum PfncFormat
  - Pixel format of the image

 <B> GetPixelFormat </B> gets the pixel format (PfncFormat) of the
 compressed image, as defined by the PFNC (Pixel Format Naming Convention). 
 Images are self-describing, so the device does not need to be queried to get
 this information.

 Compressed images are retrieved from a device (Arena::IDevice). If the
 image was retrieved from a device, the pixel format is populated by the 
 acquisition engine payload leader. The device itself is not queried as
 this data is present in the image data.

 Pixel format values are determined by the PFNC (Pixel Format Naming
 Convention) specification. The PFNC assigns a name and number to each
 pixel format, helping to standardize pixel formats. The number of bits
 per pixel can be found in each integer at bytes 5 and 6 (mask
 0x00FF0000). The pixel format can be determined by the integer using
 the GetPixelFormatName function provided by the PFNC.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice

</member>
        <member name="T:Arena.ICompressedImage">
 @class ICompressedImage

 An interface to compressed images.

 The compressed image interface helps read and interpret compressed data. It inherits
 from the buffer interface (Arena::IBuffer).

 \code{.cpp}
 	// retrieving a buffer, checking for and casting to compressed image
 	{
 		Arena::IBuffer* pBuffer = pDevice-&gt;GetBuffer(100);
 		
 		if (pBuffer-&gt;IsCompressedImage())
 		{
 			Arena::ICompressedImage* pCompressedImage = pBuffer-&gt;AsCompressedImage();
 			// ...
 		}
 	}
 \endcode
 
 In order to receive compressed data, certain pixel formats must be used,
 such as QOI_Mono8 or QOI_BayerRG8. Ensure camera supports a compressed
 image pixel format and is selected as the active pixel format.

 \code{.cpp}
 	// enabling compressed pixel formats
 	{
 		GenApi::CEnumerationPtr pPixelFormat = pNodeMap-&gt;GetNode("PixelFormat");
		pPixelFormat-&gt;FromString("QOI_Mono8");
 	}
 \endcode

 Along with the functionality of its parent class (Arena::IBuffer), compressed
 images provide access to additional information particular to images. This
 includes:
  - Offsets (Arena::ICompressedImage::GetOffsetX, 
    Arena::ICompressedImage::GetOffsetY)
  - Padding (Arena::ICompressedImage::GetPaddingX, 
    Arena::ICompressedImage::GetPaddingY)
  - Pixel information (Arena::ICompressedImage::GetPixelFormat,
    Arena::ICompressedImage::GetPixelEndianness)
  - Timestamps (Arena::ICompressedImage::GetTimestamp,
    Arena::ICompressedImage::GetTimestampNs)
 
 Width and height are not included in the functionality as the compressed image
 is simply blob data. 
 
 In order to decompress the image, utilize the image factory (Arena::ImageFactory)
 and pass the compressed image into the decompress function.
 
 \code{.cpp}
 	// decompressing compressed images
 	{
 		Arena::ICompressedImage* pCompressedImage = pBuffer-&gt;AsCompressedImage();
		Arena::IImage* pImage = Arena::ImageFactory::Decompress(pCompressedImage);
 	}
 \endcode

 @warning 
  - Should be requeued; same as other buffers.
  - Properties are lazily instantiated from the acquisition engine.

 @see 
  - Arena::IDevice
  - Arena::IBuffer
  - Arena::IImage
  - Arena::ICompressedImage

</member>
        <member name="M:Arena.IChunkData.Dispose">
 @fn virtual ~IChunkData()

 A destructor

</member>
        <member name="M:Arena.IChunkData.VerifyCRC">
 @fn virtual bool VerifyCRC()

 @return 
  - Type: bool
  - True if the calculated CRC value equals the one sent from the
    device
  - Otherwise, false

 <B> VerifyCRC </B> calculates the CRC of chunk data and verifies it
 against the CRC value sent from the device. This helps verify that no
 data has been changed or missed during transmission. This function
 calls a global helper function to calculate the CRC
 (Arena::CalculateCRC32).

 A CRC is performed by running a set of calculations on a dataset both
 before and after a transmission. The two calculated values are then
 compared for equality. If the values are the same, then the
 transmission is deemed successful; if different, then something in the
 transmission went wrong.

 A device can be set to send a CRC value by enabling its chunk data
 setting.

 \code{.cpp}
 	// Enable chunk data and the CRC chunk
 	{
 		GenApi::INodeMap* pNodeMap = pDevice-&gt;GetNodeMap();
 		
 		GenApi::CBooleanPtr pChunkModeActive = pNodeMap-&gt;GetNode("ChunkModeActive");
 		pChunkModeActive-&gt;SetValue(true);
 		
 		GenApi::CEnumerationPtr pChunkSelector = pNodeMap-&gt;GetNode("ChunkSelector");
 		GenApi::CEnumEntryPtr pCRC = pChunkSelector-&gt;GetEntryByname("CRC");
 		pChunkSelector-&gt;SetIntValue(pCRC-&gt;GetValue());
 		
 		GenApi::CBooleanPtr pChunkEnable = pNodeMap-&gt;GetNode("ChunkEnable");
 		pChunkEnable-&gt;SetValue(true);
 	}
 \endcode

 The data can then be checked by verifying the CRC.

 \code{.cpp}
 	// Verifying a buffer's data
 	{
 		Arena::IImage* pImage = pDevice-&gt;GetImage(timeout);
 		if (!pImage-&gt;VerifyCRC())
 		{
 			// data not complete
 		}
 	}
 \endcode

 @warning 
  - May throw GenICam::GenericException or other derived exception.
  - Throws an exception if chunk data disabled or not present, or if CRC chunk
    disabled.

 @see 
  - Arena::CalculateCRC
  - Arena::IImage

</member>
        <member name="M:Arena.IChunkData.DataLargerThanBuffer">
 @fn virtual bool DataLargerThanBuffer()

 @return 
  - Type: bool
  - True if the payload is larger than the buffer
  - Otherwise, false

 <B> DataLargerThanBuffer </B> returns whether or not a buffer's
 payload data is too large for the buffer.

 A buffer may be missing data if the buffer to hold the data is too
 small. This happens when the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer) does not match the expected data
 size ('PayloadSize'). This function will also return true when
 checking whether the data is larger than the buffer.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer

</member>
        <member name="M:Arena.IChunkData.IsIncomplete">
 @fn virtual bool IsIncomplete()

 @return 
  - Type: bool
  - True if the data is incomplete
  - Otherwise, false

 <B> IsIncomplete </B> returns whether or not a buffer's payload data
 is complete.

 Error handling may be required if the data is
 incomplete. An incomplete image signifies that the data size
 (Arena::IBuffer::GetSizeFilled) does not match the expected data size
 ('PayloadSize'). This is either due to missed packets or a small buffer.

 The number of missed packets may be discovered through the stream node
 map
 (Arena::IDevice::GetTLStreamNodeMap). The missed packet count feature
 ('StreamMissedPacketCount') is a cumulative count of all missed packets,
 and does not necessarily reflect the number of missed packets for any
 given buffer.

 A buffer may be missing data if the buffer to hold the data is too
 small. This happens when the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer) does not match the expected data
 size ('PayloadSize'). This function will also return true when
 checking whether the data is larger than the buffer
 (Arena::IBuffer::DataLargerThanBuffer).

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeFilled
  - Arena::IDevice::GetTLStreamNodeMap
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IBuffer::DataLargerThanBuffer

</member>
        <member name="M:Arena.IChunkData.AsImage">
 @fn virtual IImage* AsImage()

 @return 
  - Type: Arena::IImage*
  - Pointer to the original object cast to an image
  - Null on failure

 <B> AsImage </B> casts the buffer to an image (Arena::IImage). This is
 only possible if the payload contains image data not packaged as a
 chunk.

 @warning 
  - Causes undefined behaviour if buffer requeued

 @see 
  - Arena::IImage

</member>
        <member name="M:Arena.IChunkData.HasChunkData">
 @fn virtual bool HasChunkData()

 @return 
  - True if the payload has chunk data
  - Otherwise, false

 <B> HasChunkData </B> returns whether or not a buffer's payload may be
 interpreted as chunk data. Calling <B> HasChunkData </B> from chunk
 data returns true.

 <B> HasChunkData </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeChunkData
  - Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk

 It returns false if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeImage

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IChunkData.HasImageData">
 @fn virtual bool HasImageData()

 @return 
  - Type: bool
  - True if the payload has image data
  - False if the payload has image data packaged as chunk
  - Otherwise, false

 <B> HasImageData </B> returns whether or not a buffer's payload may be
 interpreted as image data.

 <B> HasImageData </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeImage
  - Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk

 It returns false if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeChunkData

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IChunkData.GetPayloadType">
 @fn virtual size_t GetPayloadType()

 @return 
  - Type: size_t
  - Represents: enum Arena::EBufferPayloadType
  - Type of payload data

 <B> GetPayloadType </B> returns a buffer's payload type
 (Arena::EBufferPayloadType), as defined in the GigE Vision specification.

 The payload type indicates how to interpret the data stored in the
 buffer.
 (Arena::IBuffer::GetData). LUCID devices may provide three ways to
 interpret the data:
  - As an image (Arena::EBufferPayloadType::BufferPayloadTypeImage)
  - As an image with chunk data appended to the end
    (Arena::EBufferPayloadType::BufferPayloadTypeImageExtended) 
  - As chunk data, which may or may not include image data as a chunk
  - (Arena::EBufferPayloadType::BufferPayloadTypeChunkData)

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetData
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IChunkData.GetFrameId">
 @fn virtual uint64_t GetFrameId()

 @return 
  - Type: uint64_t
  - Frame ID

 <B> GetFrameId </B> returns the frame ID, a sequential identifier for
 buffers.

 Frame IDs start at '1' and continue until 2^64-1
 (64-bit), at which point they roll over back to '1'. The frame ID should
 never be '0'.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

</member>
        <member name="M:Arena.IChunkData.GetSizeOfBuffer">
 @fn virtual size_t GetSizeOfBuffer()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the buffer

 <B> GetSizeOfBuffer </B> retrieves the size of the buffer.

 The size filled is often same as the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer), but not because they are one and the
 same. <B> GetSizeFilled </B> returns the number of bytes received
 whereas <B> GetSizeOfBuffer </B> returns the size of the buffer, which
 can either be allocated by the user or calculated by Arena
 (Arena::IDevice::GetNodeMap, 'PayloadSize').

 The payload size is calculated at the beginning of the stream and
 cannot be recalculated until the stream has stopped. Because of this,
 features that can affect payload size ('Width', 'Height',
 'PixelFormat') become unwritable when the stream has started.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.IChunkData.GetPayloadSize">
 @fn virtual size_t GetPayloadSize()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the intended payload

 <B> GetPayloadSize </B> retrieves the intended size of the payload.
 This is similar to the retrieved payload size
 (Arena::IBuffer::GetSizeFilled), but different in that missed data is
 included. This returns the same as the SFNC feature by the same name
 ('PayloadSize').

 @warning 
  - Causes undefined behavior if buffer requeued.

 @see 
  - Arena::IBuffer::GetSizeFilled

</member>
        <member name="M:Arena.IChunkData.GetSizeFilled">
 @fn virtual size_t GetSizeFilled()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the chunk portion of the payload

 A getter for the size of the data

 <B> GetSizeFilled </B> retrieves the size of the data of a buffer,
 excluding transport layer protocol leaders. It takes no inputs and
 returns the size of the data as output.

 The return value of <B> GetSizeFilled </B> should always be the same
 as the return value of <B> GetSizeOfBuffer </B>
 (Arena::IBuffer::GetSizeOfBuffer), but not because they are one and the
 same. <B> GetSizeFilled </B> returns the size of the data whereas <B>
 GetSizeFilled </B> returns the size of the buffer, which is set
 according to the expected payload size ('PayloadSize').

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer

</member>
        <member name="T:Arena.IChunkData">
 @class IChunkData

 An interface to a chunk data object

 The chunk data interface helps read and interpret chunk data. It inherits
 from the buffer interface (Arena::IBuffer). If chunk data is present,
 buffers (Arena::IBuffer) and images (Arena::IImage) may be cast to chunk
 data.

 \code{.cpp}
 	// retrieving a buffer, checking for and casting to chunk data
 	{
 		Arena::IBuffer* pBuffer = pDevice-&gt;GetBuffer(100);
 		
 		if (pBuffer-&gt;HasChunkData())
 		{
 			Arena::IChunkData* pChunkData = pBuffer-&gt;AsChunkData();
 			// ...
 		}
 	}
 \endcode

 The concept of chunk data is a method of adding extra data (such as CRC,
 width, height, etc.) to an image. A nuance of this concept is whether the
 additional information is appended to the back of the image or the image
 is treated as part of the chunk data. This is important for parsing the
 data. LUCID devices create chunk data by appending it to the payload.

 In order to receive chunk data with an image, chunk data must be enabled
 and configured on node map (GenApi::INodeMap, Arena::IDevice::GetNodeMap).
 Chunk data must first be activated via ('ChunkModeActive'). Each specific
 chunk must then be selected and enabled ('ChunkSelector', 'ChunkEnable').

 \code{.cpp}
 	// enabling exposure time chunk data
 	{
 		CBooleanPtr pChunkModeActive = pNodeMap-&gt;GetNode("ChunkModeActive");
 		pChunkModeActive-&gt;SetValue(true);
 		
 		CEnumerationPtr pChunkSelector = pNodeMap-&gt;GetNode("ChunkSelector");
 		CEnumEntryPtr pPixelFormat = pChunkSelector-&gt;GetEntryByName("ExposureTime");
 		pChunkSelector-&gt;SetIntValue(pPixelFormat-&gt;GetValue());
 		
 		CBooleanPtr pChunkEnable = pNodeMap-&gt;GetNode("ChunkEnable");
 		pChunkEnable-&gt;SetValue(true);
 	}
 \endcode

 Along with the functionality of its parent class (Arena::IBuffer), chunk
 data objects provide the ability to get chunks
 (Arena::IChunkData::GetChunk).

 @warning 
  - Should be requeued; same as other buffers.
  - Properties are lazily instantiated from the acquisition engine.

 @see 
  - Arena::IBuffer
  - Arena::IImage
  - Arena::IChunkData

</member>
        <member name="M:Arena.EIncModeClass.ToString(GenApi_3_3_LUCID._EIncMode)">
 @fn static GenICam::gcstring ToString(GenApi::EIncMode Value)

 @param Value
  - Type: GenApi::EInterfaceType
  - Enum value to translate

 @return 
  - Type: GenICam::gcstring
  - Translated string representation
  - "intfIUnknown" on failure

 <B> ToString </B> translates from an increment mode enum value to its
 string representation.

</member>
        <member name="T:Arena.EIncModeClass">
 @class EIncModeClass

 <B> EIncModeClass </B> is a static class based on GenApi classes of the
 same purpose. It translates from an increment mode enum (GenApi::EIncMode)
 to a string and back. For example, the following enum value can be
 translated to and from the following string representation:
  - enum: GenApi::fixedIncrement
  - string: "fixedIncrement"

 @warning 
  - Similar classes are mostly found under the GenApi namespace.

</member>
        <member name="M:Arena.EInterfaceTypeClass.ToString(GenApi_3_3_LUCID._EInterfaceType)">
 @fn static GenICam::gcstring ToString(GenApi::EInterfaceType Value)

 @param Value
  - Type: GenApi::EInterfaceType
  - Enum value to translate

 @return 
  - Type: GenICam::gcstring
  - Translated string representation
  - "intfIUnknown" on failure

 <B> ToString </B> translates from an interface type enum value to its
 string representation.

</member>
        <member name="T:Arena.EInterfaceTypeClass">
 @class EInterfaceTypeClass

 <B> EInterfaceTypeClass </B> is a static class based on GenApi classes of
 the same purpose. It translates from an interface type enum
 (GenApi::EInterfaceType) to a string and back. For example, the following
 enum value can be translated to and from the following string
 representation:
  - enum: GenApi::EInterfaceType::intfIValue
  - string: "intfIValue"

 @warning 
  - Similar classes are found mostly under the GenApi namespace.

</member>
        <member name="M:Arena.FeatureStream.Dispose">
 @fn virtual ~FeatureStream()

 A destructor

</member>
        <member name="M:Arena.FeatureStream.Read(GenICam_3_3_LUCID.gcstring)">
 @fn virtual void Read(const GenICam::gcstring fileName = "features.txt")

 @param fileName
  - Type: const GenICam::gcstring
  - Default: features.txt
  - Name of the file to read from

 @return 
  - none

 <B> Read </B> streams all selected features from a file to the node
 map
 (GenApi::INodeMap).

 Calling <B> Read </B> streams all features from a file. Selecting
 features
 (Arena::FeatureStream::Select) only applies to <B> Write </B>.

 @warning 
  - May throw GenICam::GenericException or other derived exception.
  - May throw exception related to file access permissions.
  - Selecting features only applies to write.

 @see 
  - Arena::FeatureStream::Select

</member>
        <member name="M:Arena.FeatureStream.Write(GenICam_3_3_LUCID.gcstring)">
 @fn virtual void Write(const GenICam::gcstring fileName = "features.txt")

 @param fileName
  - Type: const GenICam::gcstring
  - Default: features.txt
  - Name of the file to write to

 @return 
  - none

 <B> Write </B> streams all selected features from the node map
 (GenApi::INodeMap) to a file.

 By default, a feature stream will have a flag set to stream all
 streamable features. A subset of streamable features may be selected
 (Arena::FeatureStream::Select), reversing the flag. If a non-streamable
 feature is selected, the call will throw an exception and  the flag will
 remain unchanged.

 Essentially, if no features have been selected, <B> Write </B> will
 stream all available streamable features from the node map to the
 file; if one or more features have been selected, only the selected
 features will be streamed.

 @warning 
  - May throw GenICam::GenericException or other derived exception.
  - May throw exception related to file access permissions.

 @see 
  - Arena::FeatureStream::Select

</member>
        <member name="M:Arena.FeatureStream.#ctor(GenApi_3_3_LUCID.INodeMap*)">
 @fn FeatureStream(GenApi::INodeMap* pNodeMap)

 @param pNodeMap
  - Type: GenApi::INodeMap*
  - Pointer to the node map to stream

 The <B> constructor </B> builds a feature stream from a device's node
 map
 (GenApi::INodeMap). This node map cannot be changed later; another feature
 stream must be created to stream another node map.

 By default, a feature stream will have a flag set to stream all
 streamable features. A subset of streamable features may be selected
 (Arena::FeatureStream::Select), reversing the flag. If a non-streamable
 feature is selected, the call will throw an exception and  the flag will remain as
 it originally was.

 @see 
  - Arena::FeatureStream::Select

</member>
        <member name="M:Arena.GetVersion">
 @fn GenICam::gcstring GetVersion()

 @return
	- build version

</member>
        <member name="M:Arena.CalculateMaximumNumberOfBuffers(System.UInt64)">
 uint64_t CalculateMaximumNumberOfBuffers(size_t payloadSize)

 @param payloadSize
	- Type: size_t
	- Unit: bytes
	- Payload size of an image

 @return
	- Type: uint64_t
	- Maximum number of buffers

 <B> CalculateMaximumNumberOfBuffers </B> calculates the number of buffers
 it would take to fill 80% of the available memory.

</member>
        <member name="M:Arena.CloseSystem(Arena.ISystem*)">
 @fn void CloseSystem(ISystem* pSystem)

 @param pSystem
  - Type: ISystem*
  - The system object

 @return 
  - none

 <B> CloseSystem </B> cleans up the system (Arena::ISystem) and
 deinitializes the Arena SDK, deallocating all memory.

 @warning 
  - The system must be closed.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::ISystem

</member>
        <member name="M:Arena.OpenSystem">
 @fn ISystem* OpenSystem()

 @return 
  - Type: ISystem*
  - The system object

 <B> OpenSystem </B> initializes the Arena SDK and retrieves the system
 object (Arena::ISystem). The system must be closed, or memory will leak.

 \code{.cpp}
 	// opening and closing a system
 	{
 		Arena::ISystem* pSystem = Arena::OpenSystem();
 		// ...
 		Arena::CloseSystem(pSystem);
 	}
 \endcode

 @warning 
  - Only one system may be opened at a time.
  - System must be closed.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::ISystem
  - Arena::OpenSystem
  - Arena::CloseSystem

</member>
        <member name="M:Arena.ISystem.Dispose">
 @fn virtual ~ISystem()

 A destructor

</member>
        <member name="M:Arena.ISystem.RemoveUnicastDiscoveryDevice(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 @fn virtual void RemoveUnicastDiscoveryDevice(const char* pUnicastDeviceIP)

 @param pUnicastDeviceIP
  - Type: const char*
  - A pointer to an ipAddress string
 
 @return
  - none

 <B> RemoveUnicastDiscoveryDevice </B> unregisters an IP address for a device on a 
 different subnet than the host. To remove all registered devices,
 pass NULL for the IP address argument.


 \code{.cpp}
   // Add a device on a different subnet than the host to the remote devices list
   {
		Arena::ISystem* pSystem = Arena::OpenSystem();

		// Add remote device to the unicast discovery list
		pSystem-&gt;AddUnicastDiscoveryDevice("192.168.0.10");
 
		// Enumerate all devices including registered devices on different subnets.
		pSystem-&gt;UpdateDevices(100);
 
		// do something
		// ...
 
		// Remove specific remote device from the unicast discovery list
		pSystem-&gt;RemoveUnicastDiscovery("192.168.0.10");
 
		// Remove all remote devices from the unicast discovery list
		pSystem-&gt;RemoveUnicastDiscoveryDevice(NULL);
   }
 \endcode

 @see
  - System:AddUnicastDiscoveryDevice

</member>
        <member name="M:Arena.ISystem.AddUnicastDiscoveryDevice(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 @fn virtual void AddUnicastDiscoveryDevice(const char* pUnicastDeviceIP)

 @param pUnicastDeviceIP
  - Type: const char*
  - A pointer to an ipAddress string
 
 @return
  - none

 <B> AddUnicastDiscoveryDevice </B> registers an IP address for a device on a 
 different subnet than the host. Registered devices will be enumerated 
 using unicast discovery messages. The list of remote devices will 
 persist until they are removed using RemoveUnicastDiscoveryDevice() or until 
 the application terminates. Unicast discovery's will be sent when
 UpdateDevices() is called.


 \code{.cpp}
   // Add a device on a different subnet than the host to the remote devices list
   {
		Arena::ISystem* pSystem = Arena::OpenSystem();

		// Add remote device to the unicast discovery list
		pSystem-&gt;AddUnicastDiscoveryDevice("192.168.0.10");
 
		// Enumerate all devices including registered devices on different subnets.
		pSystem-&gt;UpdateDevices(100);
   }
 \endcode

 @see
  - System:RemoveUnicastDiscoveryDevice

</member>
        <member name="M:Arena.ISystem.DeregisterAllDeviceDisconnectCallbacks">
 @fn virtual bool DeregisterAllDeviceDisconnectCallbacks()

 @return
  - none

 <B> DeregisterAllDeviceDisconnectCallbacks </B> deregisters all previously
 registered callback objects. Callbacks can be unregistered whether or
 not the device is currently connected. To deregister an individual
 callback, DeregisterDeviceDisconnectCallback.


 \code{.cpp}
   // Register callback object
   {
     std::string camSerial = deviceInfos[0].SerialNumber();
     DeviceDisconnectCallback* pCallbackHandler = new DeviceDisconnectCallback();

     pDevice-&gt;RegisterDeviceDisconnectCallback(pDevice, pCallbackHandler);

     pDevice-&gt;DeregisterAllDeviceDisconnectCallbacks(pCallbackHandler);

     delete pCallbackHandler;
   }
 \endcode

 @see
  - System:RegisterDeviceDisconnectCallback
  - System:DeregisterDeviceDisconnectCallback

</member>
        <member name="M:Arena.ISystem.DeregisterDeviceDisconnectCallback(Arena.IDisconnectCallback*)">
 @fn virtual void DeregisterDeviceDisconnectCallback(IDisconnectCallback* pCallback)

 @param pCallback
  - Type: IDisconnectCallback*
  - A pointer to an IDisconnectCallback object which implements the
    OnDeviceDisconnected() function

 @return
  - none

 <B> DeregisterDeviceDisconnectCallback </B> unregisters a previously registered
 callback object. Callbacks can be unregistered whether or not the
 device is currently connected. To deregister all callbacks at once use
 DeregisterAllDeviceDisconnectCallbacks.

 DeregisterDeviceDisconnectCallback will throw:
  - InvalidArgumentException if the callback argument is NULL

 \code{.cpp}
   // Register callback object
   {
     std::string camSerial = deviceInfos[0].SerialNumber();
     DeviceDisconnectCallback* pCallbackHandler = new DeviceDisconnectCallback();

     pDevice-&gt;RegisterDeviceDisconnectCallback(pDevice, pCallbackHandler);

     pDevice-&gt;DeregisterDeviceDisconnectCallback(pCallbackHandler);

     delete pCallbackHandler;
   }
 \endcode

 @see
  - System:RegisterDeviceDisconnectCallback
  - System:DeregisterAllDeviceDisconnectCallbacks

</member>
        <member name="M:Arena.ISystem.RegisterDeviceDisconnectCallback(Arena.IDevice*,Arena.IDisconnectCallback*)">
 @fn virtual void RegisterDeviceDisconnectCallback(IDevice* pDevice, IDisconnectCallback* pCallback)

 @param pCallback
  - Type: IDeviceDisconnectCallback*
  - A pointer to an IDeviceDisconnectCallback object which implements the
    OnDeviceDisconnected() function

 @return
  - none

 <B> RegisterDeviceDisconnectCallback </B> registers a callback object derived
 from Arena::IDeviceDisconnectCallback, implementing the OnDeviceDisconnected() function. When
 an registered device is disconnected, the user-implemented OnDeviceDisconnected() will be called. The
 user-implemented OnDeviceDisconnected() will receive a pointer to the device that was disconnected.
 (Arena::IDevice* pDevice).

 Callbacks can be registered whether or not the device is currently
 connected. Multiple callbacks can be registered for a device and each
 will be called sequentially in the order that they have been
 registered in.

 RegisterDeviceDisconnectCallback will throw:
  - InvalidArgumentException if the callback argument is NULL
  - LogicalErrorException if the callback has already been registered


 \code{.cpp}
   // Register callback object
   {
     std::string camSerial = deviceInfos[0].SerialNumber();
     DeviceDisconnectCallback* pCallbackHandler = new DeviceDisconnectCallback();

     pDevice-&gt;RegisterDeviceDisconnectCallback(pDevice, pCallbackHandler);

     pDevice-&gt;DeregisterDeviceDisconnectCallback(pCallbackHandler);

     delete pCallbackHandler;
   }
 \endcode


 @see
  - System:DeregisterDeviceDisconnectCallback
  - System:DeregisterAllDeviceDisconnectCallbacks

</member>
        <member name="M:Arena.ISystem.ForceIp(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*)">
 @fn virtual void ForceIp(const char* pMacAddress, const char* pIpAddress, const char* pSubnetMask, const char* pDefaultGateway)

 @param pMacAddress
	- Type: const char*
	- MAC address of the device to force

 @param pIpAddress
	- Type: const char*
	- IP address to force

 @param pSubnetMask
	- Type: const char*
	- subnet mask to force

 @param pDefaultGateway
	- Type: const char*
	- default gateway to force

 Forces the device that matches the macAddress to a temporary new
 ipAddress, subnetMask and defaultGateway

 Arena::ISystem::ForceIp will send a ForceIP command out on all the
 interfaces This call also updates the internal list of interfaces in
 case that has not been done yet. The ForceIP command will be a network
 wide broadcast 255.255.255.255 and will request an acknowledgement to be
 broadcast back to the host.

 @warning
  - This function may throw an exception derived from
    GenApi::GenericException upon failure.

 @see
  - Arena::ISystem::ForceIp

</member>
        <member name="M:Arena.ISystem.ForceIp(System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
 @fn virtual void ForceIp(uint64_t macAddress, uint64_t ipAddress, uint64_t subnetMask, uint64_t defaultGateway)

 @param macAddress
	- Type: uint64_t 
	- MAC address of the device to force

 @param ipAddress 
	- Type: uint64_t
	- IP address to force

 @param subnetMask
	- Type: uint64_t
	- subnet mask to force

 @param defaultGateway
	- Type: uint64_t
	- default gateway to force

 Forces the device that matches the macAddress to a temporary new
 ipAddress, subnetMask and defaultGateway

 Arena::ISystem::ForceIp will send a ForceIP command out on all the
 interfaces This call also updates the internal list of interfaces in
 case that has not been done yet. The ForceIP command will be a network
 wide broadcast 255.255.255.255 and will request an acknowledgement to be
 broadcast back to the host.

 @warning 
  - This function may throw an exception derived from
    GenApi::GenericException upon failure.

 @see 
  - Arena::ISystem::ForceIp

</member>
        <member name="M:Arena.ISystem.GetTLSystemNodeMap">
 @fn virtual GenApi::INodeMap* GetTLSystemNodeMap()

 @return 
  - Type: GenApi::INodeMap*
  - GenTL node map for the system

 <B> GetTLSystemNodeMap </B> retrieves the GenTL system node map
 (GenApi::INodeMap), used to access system-related nodes (GenApi::INode).

 As a simple getter, <B> GetTLSystemNodeMap </B> retrieves this node
 map without doing anything to initialize, manage, or maintain it. This
 node map is initialized when the system is opened (Arena::OpenSystem)
 and deinitialized when the system is closed (Arena::CloseSystem).
 Because node maps are cleaned up internally, retrieving multiple
 pointers to the same node map is permitted.

 All available nodes can be viewed in ArenaView or the examples
 (Cpp_Explore_NodeMaps) example. Nodes in this node map include nodes
 related to:
  - Arena SDK information
  - GenTL and GEV versioning information
  - The ability to update and select interfaces
  - Interface discovery and IP configuration information

 Arena provides access to five different node maps. This one comes from
 the device and describes all of its features. Please check the device
 documentation for more information on these features.
  - Device (Arena::IDevice::GetNodeMap)

 The other four, including this one, node maps describe and provide
 access to information and settings through the software rather than
 the device.
  - System GenTL (Arena::ISystem::GetTLSystemNodeMap)
  - Stream GenTL (Arena::IDevice::GetTLStreamNodeMap)
  - Device GenTL (Arena::IDevice::GetTLDeviceNodeMap)
  - Interface GenTL (Arena::IDevice::GetTLInterfaceNodeMap)

 @warning 
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::OpenSystem
  - Arena::CloseSystem
  - Arena::IDevice::GetNodeMap
  - Arena::ISystem::GetTLSystemNodeMap
  - Arena::IDevice::GetTLStreamNodeMap
  - Arena::IDevice::GetTLDeviceNodeMap
  - Arena::IDevice::GetTLInterfaceNodeMap

</member>
        <member name="M:Arena.ISystem.DestroyDevice(Arena.IDevice*)">
 @fn virtual void DestroyDevice(IDevice* pDevice)

 @param pDevice
  - Type: Arena::IDevice*
  - Device to destroy

 @return 
  - none

 <B> DestroyDevice </B> destroys and cleans up the internal memory of a
 device (Arena::IDevice). Devices that have been created
 (Arena::ISystem::CreateDevice) must be destroyed.

 When called, <B> DestroyDevice </B> deletes all internal memory
 associated with a device: if a stream has been left open, it is
 closed; all node maps and chunk data adapters are deallocated; events
 are unregistered and the message channel closed; finally, the control
 channel socket is closed, allowing the device to be opened in
 read-write mode again.

 Destroying a device does not reset device settings, and will not
 return a camera to a stable state. To reset settings or return to a
 stable state, power-cycle a device (unplug and plug back in) or reset
 it ('DeviceReset' feature).

 @warning 
  - Devices must be destroyed.
  - Does not affect device settings.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ISystem::CreateDevice

</member>
        <member name="M:Arena.ISystem.CreateDevice(Arena.DeviceInfo)">
 @fn virtual IDevice* CreateDevice(DeviceInfo info)

 @param info
  - Type: Arena::DeviceInfo
  - Device information object of the device to create

 @return 
  - Type: Arena::IDevice*
  - Pointer to an initialized, ready-to-use device

 <B> CreateDevice </B> creates and initializes a device using a single
 device information object (Arena::DeviceInfo). It must be called after
 devices have been retrieved (Arena::ISystem::GetDevices). The device
 must be destroyed (Arena::ISystem::DestroyDevice) when no longer
 needed.

 When called, <B> CreateDevice </B> prepares the camera for user
 interaction, opening the control channel socket and initializing all
 node maps (GenApi::INodeMap). The returned device is ready to stream
 images, send events, and read or customize features.

 A single process may only create a single device once, but a single
 device may be opened on multiple processes. The first process to
 create the device is given read-write access. Additional processes are
 given read-only access. With read-only access, processes can read
 features and receive images and events; they cannot, however, write
 values, start the image stream, or initialize events.

 @warning 
  - Provides read-write access only to initial process to create
    device; following processes given read-only access.
  - Devices must be destroyed.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::DeviceInfo
  - Arena::IDevice
  - Arena::ISystem::GetDevices
  - Arena::ISystem::DestroyDevice

</member>
        <member name="M:Arena.ISystem.UpdateDevices(Arena.InterfaceInfo,System.UInt64)">
 @fn virtual bool UpdateDevices(InterfaceInfo ifaceInfo, uint64_t timeout)

 @param ifaceInfo
  - Type: InterfaceInfo
  - Specific interface to enumerate devices on

 @param timeout
  - Type: uint64_t
  - Unit: milliseconds
  - Time to wait for connected devices to respond

 @return 
  - Type: bool
  - True on first call that a device is found
  - True if the device list has changed since the last call
  - Otherwise, false

 <B> UpdateDevices </B> updates the internal list of devices (along
 with their relevant interfaces). It must be called before retrieving
 the list of devices (Arena::ISystem::GetDevices) or any time that an
 updated device list might be necessary.

 When called, the system broadcasts a discovery packet to all
 interfaces, waiting until the end of the timeout for any responses
 from enumerated devices. The new, updated list of devices is compared
 to the old list. If the contents of the list have changed, 'true' is
 returned; otherwise 'false'.

 The GigE Vision spec requires devices respond to a broadcast discovery
 packet within one second unless set otherwise
 (Arena::IDevice::GetNodeMap, 'DiscoveryAckDelay'). LUCID devices are
 set to respond within 100 ms. Therefore, 100 works as an appropriate
 timeout value in many use cases. This response time can be customized
 through the 'DiscoveryAckDelay' feature, if supported. The timeout
 value should reflect any such changes.

 @warning 
  - Slightly affects bandwidth usage due to the broadcasting of
    discovery packets.
  - Discovers devices on all subnets, even when unable to communicate
    with them due to IP configuration.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::ISystem::GetDevices
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.ISystem.UpdateDevices(System.UInt64)">
 @fn virtual bool UpdateDevices(uint64_t timeout)

 @param timeout
  - Type: uint64_t
  - Unit: milliseconds
  - Time to wait for connected devices to respond

 @return 
  - Type: bool
  - True on first call that a device is found
  - True if the device list has changed since the last call
  - Otherwise, false

 <B> UpdateDevices </B> updates the internal list of devices (along
 with their relevant interfaces). It must be called before retrieving
 the list of devices (Arena::ISystem::GetDevices) or any time that an
 updated device list might be necessary.

 When called, the system broadcasts a discovery packet to all
 interfaces, waiting until the end of the timeout for any responses
 from enumerated devices. The new, updated list of devices is compared
 to the old list. If the contents of the list have changed, 'true' is
 returned; otherwise 'false'.

 The GigE Vision spec requires devices respond to a broadcast discovery
 packet within one second unless set otherwise
 (Arena::IDevice::GetNodeMap, 'DiscoveryAckDelay'). LUCID devices are
 set to respond within 100 ms. Therefore, 100 works as an appropriate
 timeout value in many use cases. This response time can be customized
 through the 'DiscoveryAckDelay' feature, if supported. The timeout
 value should reflect any such changes.

 @warning 
  - Slightly affects bandwidth usage due to the broadcasting of
    discovery packets.
  - Discovers devices on all subnets, even when unable to communicate
    with them due to IP configuration.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::ISystem::GetDevices
  - Arena::IDevice::GetNodeMap

</member>
        <member name="T:Arena.ISystem">
 @class ISystem

 An interface to the system object

 The system is the entry point to the Arena SDK. It is retrieved and
 cleaned up through global functions (Arena::OpenSystem,
 Arena::CloseSystem).

 \code{.cpp}
 	// opening and closing the system
 	{
 		Arena::ISystem* pSystem = Arena::OpenSystem();
 		// do something
 		// ...
 		Arena::CloseSystem(pSystem);
 	}
 \endcode

 It manages devices (Arena::DeviceInfo, Arena::IDevice) and the system node
 map (GenApi::INodeMap) by:
  - maintaing a list of enumerated devices
    (Arena::ISystem::UpdateDevices, Arena::ISystem::GetDevices),
  - creating and destroying devices (Arena::ISystem::CreateDevice,
    Arena::ISystem::DestroyDevice),
  - and providing access to its node map
    (Arena::ISystem::GetTLSystemNodeMap).

 @warning 
  - May only be opened once; subsequent attempts will throw an exception.
  - Must be closed as final step with Arena; otherwise, memory will leak.

 @see 
  - Arena::ISystem
  - Arena::DeviceInfo
  - Arena::IDevice

</member>
        <member name="M:Arena.IDevice.Dispose">
 @fn virtual ~IDevice()

 A destructor

</member>
        <member name="M:Arena.IDevice.GetNextEvsTriggerEvent(System.UInt64)">
		* @fn virtual EvsRawTriggerEvent GetNextEvsTriggerEvent(uint64_t timeout)
		*
		* @param timeout
		*  - Type: uint64_t
		*  - Unit: milliseconds
		*  - Maximum time to wait for a EVT 3.0 external trigger event
		*
		* @return
		 *  - Type: EvsRawTriggerEvent
		 *  - A structure containing details of the trigger event
		*
		*
		* <B> GetNextEvsTriggerEvent </B> will wait until a trigger event has been
		* decoded from received event data from a camera. It must be called after 
		* the stream has started (Arena::IDevice::StartStream) and before the stream 
		* has stopped (Arena::IDevice::StopStream).
		*
		* This function can be used to track external trigger events decoded on the 
		* currently active event stream.
		*
		* @warning
		*  - May throw GenICam::GenericException or other derived exception.
		*
		* @see
		*  - struct Arena::EvsRawTriggerEvent

</member>
        <member name="M:Arena.IDevice.DeregisterAllImageCallbacks">
		* @fn virtual bool DeregisterAllImageCallbacks()
		*
		* @return
		 *  - Type: bool
		 *  - True if there were any callbacks registered before removing them
		 *    all. Otherwise false.
		*
		 * <B> DeregisterAllImageCallbacks </B> deregisters all previously
		 * registered callback objects. Callbacks can be unregistered whether or
		 * not the device is currently streaming. To deregister an individual
		 * callback, DeregisterImageCallback.
		*
		*
		* \code{.cpp}
		*   // Register callback object
		*   {
		*     std::string camSerial = deviceInfos[0].SerialNumber();
		*     ImageCallback* pCallbackHandler = new ImageCallback(camSerial);
		*
		*     pDevice-&gt;RegisterImageCallback(pCallbackHandler);
		*
		*     pDevice-&gt;StartStream();
		*     Sleep(5000);
		*     pDevice-&gt;StopStream();
		*
		*     pDevice-&gt;DeregisterAllImageCallbacks();
		*
		*     delete pCallbackHandler;
		*   }
		* \endcode
		*
		* @see
		 *  - Device:RegisterImageCallback
		 *  - Device:DeregisterImageCallback

</member>
        <member name="M:Arena.IDevice.DeregisterImageCallback(Arena.IImageCallback*)">
		* @fn virtual bool DeregisterImageCallback(IImageCallback* callback)
		*
		* @param callback
		 *  - Type: IImageCallback*
		 *  - A pointer to an IImageCallback object which implements the
		 *    OnImage() function
		*
		* @return
		 *  - Type: bool
		 *  - True if the specfied callback was in the list of registered
		 *    callbacks. Otherwise false.
		*
		 * <B> DeregisterImageCallback </B> unregisters a previously registered
		 * callback object. Callbacks can be unregistered whether or not the
		 * device is currently streaming. To deregister all callbacks at once use
		 * DeregisterAllImageCallbacks.
		*
		 * RegisterImageCallback will throw:
		 *  - InvalidArgumentException if the callback argument is NULL
		*
		* \code{.cpp}
		*   // Register callback object
		*   {
		*     std::string camSerial = deviceInfos[0].SerialNumber();
		*     ImageCallback* pCallbackHandler = new ImageCallback(camSerial);
		*
		*     pDevice-&gt;RegisterImageCallback(pCallbackHandler);
		*
		*     pDevice-&gt;StartStream();
		*     Sleep(5000);
		*     pDevice-&gt;StopStream();
		*
		*     pDevice-&gt;DeregisterImageCallback(pCallbackHandler);
		*
		*     delete pCallbackHandler;
		*   }
		* \endcode
		*
		* @see
		 *  - Device:RegisterImageCallback
		 *  - Device:DeregisterAllImageCallbacks

</member>
        <member name="M:Arena.IDevice.RegisterImageCallback(Arena.IImageCallback*)">
		* @fn virtual void RegisterImageCallback(IImageCallback* callback, void* pParam = NULL)
		*
		* @param callback
		 *  - Type: IImageCallback*
		 *  - A pointer to an IImageCallback object which implements the
		 *    OnImage() function
		*
		* @return
				 *  - none
		*
		 * <B> RegisterImageCallback </B> registers a callback object derived
		 * from Arena::IImageCallback, implementing the OnImage() function. When
		 * an image arrives, the user-implemented OnImage() will be called. The
		 * user-implemented OnImage() will receive a pointer to the image data
		 * (Arena::IImage* pImage).
		* 
		 * Callbacks can be registered whether or not the device is currently
		 * streaming. Multiple callbacks can be registered for a device and each
		 * will be called sequentially in the order that they have been
		 * registered in.
		*
		 * RegisterImageCallback will throw:
		 *  - InvalidArgumentException if the callback argument is NULL
		 *  - LogicalErrorException if the callback has already been registered
		* 
		* 
		* \code{.cpp}
		*   // Register callback object
		*   {
		*     std::string camSerial = deviceInfos[0].SerialNumber();
		*     ImageCallback* pCallbackHandler = new ImageCallback(camSerial);
		*
		*     pDevice-&gt;RegisterImageCallback(pCallbackHandler);
		*
		*     pDevice-&gt;StartStream();
		*     Sleep(5000);
		*     pDevice-&gt;StopStream();
		*
		*     pDevice-&gt;DeregisterImageCallback(pCallbackHandler);
		*
		*     delete pCallbackHandler;
		*   }
		* \endcode
		*
		* @warning
		 *  - Device::GetImage() should not be called while callbacks are
		 *    registered for a device.
		 *  - The user-implemented OnImage() should complete in a timely manner
		 *    to ensure that image reception is not impeded as the internal grab
		 *    thread is blocked while the callbacks are running. If the required
		 *    work cannot be performed quickly it is recommended that the image
		 *    be copied in OnImage() so that control can be returned to the
		 *    library and the image can be processed in a separate thread.
		*
		* @see
		 *  - Device:DeregisterImageCallback
		 *  - Device:DeregisterAllImageCallback

</member>
        <member name="M:Arena.IDevice.GetNodeMap">
 @fn virtual GenApi::INodeMap* GetNodeMap()

 @return 
  - Type: GenApi::INodeMap*
  - Pointer to the main node map for the device

 <B> GetNodeMap </B> retrieves the already initialized main node map
 (GenApi::INodeMap), used to access a device's complete feature set of
 nodes (GenApi::INode).

 As a simple getter, <B> GetNodeMap </B> retrieves this node map
 without doing anything to initialize, manage, or maintain it. This
 node map is initialized when the device is created with
 (Arena::ISystem::CreateDevice) and deinitialized when the device is
 destroyed
 (Arena::ISystem::DestroyDevice). Because node maps are cleaned up
 internally, retrieving multiple pointers to the same node map is
 permitted.

 The node map is built from XMLs stored on the device itself. The XML
 is downloaded and parsed before constructing and initializing the node
 map. This node map describes and provides access to all device
 features, and may vary from device to device. LUCID products conform
 to the SFNC 2.3 specification. Note that both chunk data and event
 data are updated on this node map.

 Arena provides access to five different node maps. This one comes from
 the device and describes all of its features. Please check the device
 documentation for more information on these features.
  - Device (Arena::IDevice::GetNodeMap)

 The other four node maps describe and provide access to information
 and settings through the software rather than the device.
  - System GenTL (Arena::ISystem::GetNodeMap)
  - Stream GenTL (Arena::IDevice::GetTLStreamNodeMap)
  - Device GenTL (Arena::IDevice::GetTLDeviceNodeMap)
  - Interface GenTL (Arena::IDevice::GetTLInterfaceNodeMap)

 The most noticeable difference between the two device node maps is that
 the GenTL device node map has only a small set of features compared to
 the main node map. There are a few features that overlap. For example,
 the difference between retrieving the serial number
 ('DeviceSerialNumber') is that using the main node map queries the
 camera directly whereas the GenTL node map queries a set of
 information cached at device creation. The result, however, should be
 the same. Basically, the GenTL node map queries the software for
 information whereas the main node map queries the device.

 @warning 
  - Provides access to main node map, which is not to be confused with the
    GenTL device node map.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::ISystem::CreateDevice
  - Arena::ISystem::DestroyDevice
  - Arena::IDevice::GetNodeMap
  - Arena::ISystem::GetNodeMap
  - Arena::IDevice::GetTLStreamNodeMap
  - Arena::IDevice::GetTLDeviceNodeMap
  - Arena::IDevice::GetTLInterfaceNodeMap

</member>
        <member name="M:Arena.IDevice.DeinitializeEvents">
 @fn virtual void DeinitializeEvents()

 @return 
  - none

 <B> DeinitializeEvents </B> stops the underlying events engine from
 listening for messages, shutting it down and cleaning it up. It should
 be called only after the events infrastructure has been initialized
 (Arena::IDevice::InitializeEvents) and after all events have been
 processed (Arena::IDevice::WaitOnEvent).

 Roughly speaking, <B> DeinitializeEvents </B> takes all necessary
 steps to undoing and cleaning up the event infrastructure's
 initialization
 (Arena::IDevice::InitializeEvents). This includes: 
  - Stopping the worker thread set up to listen for events.
  - Closes the message channel socket.
  - Unregisters all event buffers and deallocates their memory.

 @warning 
  - Event infrastructure must be deinitialized.
  - Stops events processing.
  - Deallocates event data that has not yet been processed.
  - May throw GenICam::GenericException or other derived exception.

 Arena::IDevice::DeinitializeEvents will perform these actions:
  - Stop the listening thread.
  - Shut down the message channel socket.
  - Unregister all buffers and clean up memory that was allocated for
    them.

 @see 
  - Arena::IDevice::InitializeEvents
  - Arena::IDevice::WaitOnEvent
  - Arena::IDevice::DeinitializeEvents

</member>
        <member name="M:Arena.IDevice.WaitForNextLeader(System.UInt64)">
 @fn virtual void WaitForNextLeader(uint64_t timeout)

 @param timeout
  - Type: uint64_t
  - Unit: milliseconds
  - Maximum time to wait for a buffer

 @return
  - Type: none

 <B> WaitForNextLeader </B> will wait until the leader for the next image
 has arrived. It must be called after the stream has started
 (Arena::IDevice::StartStream) and before the stream has stopped
 (Arena::IDevice::StopStream).

 This function can be used to determine when the host has received the
 leader for the next image. Note that if the time that the camera has
 finished the exposure for the next image is desired, it is
 recommended to use the GenICam ExposureEnd Event instead.

 @warning
  - May throw GenICam::GenericException or other derived exception.

 @see
  - Arena::IDevice::StartStream
  - Arena::IDevice::StopStream

</member>
        <member name="M:Arena.IDevice.RequeueBuffer(Arena.IBuffer*)">
 @fn virtual void RequeueBuffer(IBuffer* pBuffer)

 @param pBuffer
  - Type: Arena::IBuffer*
  - Buffer to requeue

 @return 
  - none

 <B> RequeueBuffer </B> relinquishes control of a buffer
 (Arena::IBuffer, Arena::IImage, Arena::IChunkData) back to Arena. It
 must be called after a buffer has been retrieved
 (Arena::IDevice::GetBuffer, Arena::IDevice::GetImage).

 When called, <B> RequeueBuffer </B> deallocates any lazily
 instantiated memory and returns the internal buffer to the acquisition
 engine's input queue, where it can be filled with new data. If enough
 buffers have been removed from the acquisition engine (i.e. not
 requeued), it is possible to starve the acquisition engine. If this
 happens and depending on the buffer handling mode
 (Arena::IDevice::GetTLStreamNodeMap, 'StreamBufferHandlingMode'), data
 may start being dropped or buffers may start being recycled.

 It is a best practice to requeue buffers as soon as they are
 no longer needed. If image data is needed for a longer period of time
 (i.e. for processing), it is recommended to copy the data
 (Arena::ImageFactory::Create) and requeue the buffer.

 It is important to only call <B> RequeueBuffer </B> on buffers
 retrieved from a device (Arena::IDevice::GetBuffer,
 Arena::IDevice::GetImage), and not on images created through the image
 factory (Arena::ImageFactory).

 \code{.cpp}
 	// one image is retrieved from a buffer and then requeued
 	// another is created through the image factory and then destroyed
 	{
 		Arena::IImage* pRetrievedImage = pDevice-&gt;GetImage();
 		// ...
 		pDevice-&gt;RequeueBuffer(pRetrievedImage);
 		
 		Arena::IImage* pCreatedImage = Arena::ImageFactory::Create(pData, height, width, bpp, size, pixelFormat);
 		// ...
 		Arena::ImageFactory::Destroy(pCreatedImage);
 	}
 \endcode

 @warning 
  - Buffers should be requeued.
  - Used only on buffers retrieved from a device, not on images
    created through the image factory.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer
  - Arena::IImage
  - Arena::IChunkData
  - Arena::ImageFactory
  - Arena::IDevice::GetBuffer
  - Arena::IDevice::GetImage
  - Arena::IDevice::GetTLStreamNodeMap
  - Arena::ImageFactory::Create
  - Arena::ImageFactory::Destroy

</member>
        <member name="M:Arena.IDevice.GetCompressedImage(System.UInt64)">
 @fn virtual ICompressedImage* GetCompressedImage(uint64_t timeout)

 @param timeout
  - Type: uint64_t
  - Unit: milliseconds
  - Maximum time to wait for an image

 @return 
  - Type:: Arena::ICompressedImage*
  - Pointer to the next buffer in the output queue if it contains
    compressed image data
  - Otherwise, null

 <B> GetImage </B> retrieves a compressed image (Arena::ICompressedImage)
 from the device. It must be called after the stream has started
 (Arena::IDevice::StartStream) and before the stream has stopped
 (Arena::IDevice::StopStream). Retrieved images must be requeued
 (Arena::IDevice::RequeueBuffer).

 <B> GetCompressedImage </B> is essentially the same call as <B> GetBuffer </B>
 (Arena::IDevice::GetBuffer), just with an additional step. Internally, <B>
 GetCompressedImage </B> calls <B> GetBuffer </B>, which returns a buffer. It
 then attempts to cast the buffer to a compressed image before returning it. If
 the data in the buffer is that of a compressed image, the cast succeeds and the
 image is returned successfully. If not, the cast fails and NULL is
 returned.

 When called, <B> GetBuffer </B> checks the output queue for
 image/chunk data, grabbing the first buffer in the queue. If nothing
 is in the output queue, the call will wait until something arrives. If
 nothing arrives before expiration of the timeout, a
 GenICam::TimeoutException is thrown.

 <B> GetBuffer </B> is a blocking call. If it is called with a timeout
 of 20 seconds and nothing arrives in the output queue, then its thread
 will be blocked for the full 20 seconds. However, as the timeout is a
 maximum, as soon as something arrives in the output queue, it will be
 returned, not waiting for the full timeout. A timeout value of 0
 ensures the call will not block, throwing instead of waiting if
 nothing is in the output queue.

 <B> GetCompressedImage </B> does not verify image quality. If an incomplete
 image is returned, the call will not throw an exception and the image will be
 returned as is. It is recommended to verify each image's completion
 (Arena::ICompressedImage::IsIncomplete).

 \code{.cpp}
 	// retrieving a compressed image, verifying its completion, and requeuing its buffer
 	{
 		Arena::ICompressedImage* pCompressedImage = pDevice-&gt;GetCompressedImage(100);
 		if (pCompressedImage-&gt;IsIncomplete())
 		{
 			// handle error
 			// ...
 		}
 		// do something
 		// ...
 		pDevice-&gt;RequeueBuffer(pCompressedImage);
 	}
 \endcode

 It is a best practice to requeue buffers
 (Arena::IDevice::RequeueBuffer) as soon as they are no longer needed in
 order to prevent starvation of the acquisition engine. If image data
 is needed for longer (i.e. for processing), it is
 recommended to copy the data (Arena::ImageFactory::CreateCompressedImage) and requeue
 the buffer.

 @warning 
  - Does not guarantee valid compressed image data.
  - Returns NULL for non-image formats.
  - Compressed images should be requeued to prevent starvation of the
    acquisition engine.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::ICompressedImage
  - Arena::IDevice::StartStream
  - Arena::IDevice::StopStream
  - Arena::IDevice::RequeueBuffer
  - Arena::IDevice::GetBuffer
  - Arena::ICompressedImage::IsIncomplete
  - Arena::ImageFactory::CreateCompressedImage

</member>
        <member name="M:Arena.IDevice.GetImage(System.UInt64)">
 @fn virtual IImage* GetImage(uint64_t timeout)

 @param timeout
  - Type: uint64_t
  - Unit: milliseconds
  - Maximum time to wait for an image

 @return 
  - Type:: Arena::IImage*
  - Pointer to the next buffer in the output queue if it contains
    image data
  - Otherwise, null

 <B> GetImage </B> retrieves an image (Arena::IImage) from the device.
 It must be called after the stream has started
 (Arena::IDevice::StartStream) and before the stream has stopped
 (Arena::IDevice::StopStream). Retrieved images must be requeued
 (Arena::IDevice::RequeueBuffer).

 <B> GetImage </B> is essentially the same call as <B> GetBuffer </B>
 (Arena::IDevice::GetBuffer), just with an additional step. Internally, <B>
 GetImage </B> calls <B> GetBuffer </B>, which returns a buffer. It
 then attempts to cast the buffer to an image before returning it. If
 the data in the buffer is that of an image, the cast succeeds and the
 image is returned successfully. If not, the cast fails and NULL is
 returned.

 When called, <B> GetBuffer </B> checks the output queue for
 image/chunk data, grabbing the first buffer in the queue. If nothing
 is in the output queue, the call will wait until something arrives. If
 nothing arrives before expiration of the timeout, a
 GenICam::TimeoutException is thrown.

 <B> GetBuffer </B> is a blocking call. If it is called with a timeout
 of 20 seconds and nothing arrives in the output queue, then its thread
 will be blocked for the full 20 seconds. However, as the timeout is a
 maximum, as soon as something arrives in the output queue, it will be
 returned, not waiting for the full timeout. A timeout value of 0
 ensures the call will not block, throwing instead of waiting if
 nothing is in the output queue.

 <B> GetImage </B> does not verify image quality. If an incomplete
 image is returned, the call will not throw an exception and the image will be
 returned as is. It is recommended to verify each image's completion
 (Arena::IImage::IsIncomplete).

 \code{.cpp}
 	// retrieving an image, verifying its completion, and requeuing its buffer
 	{
 		Arena::IImage* pImage = pDevice-&gt;GetImage(100);
 		if (pImage-&gt;IsIncomplete())
 		{
 			// handle error
 			// ...
 		}
 		// do something
 		// ...
 		pDevice-&gt;RequeueBuffer(pImage);
 	}
 \endcode

 It is a best practice to requeue buffers
 (Arena::IDevice::RequeueBuffer) as soon as they are no longer needed in
 order to prevent starvation of the acquisition engine. If image data
 is needed for longer (i.e. for processing), it is
 recommended to copy the data (Arena::ImageFactory::Create) and requeue
 the buffer.

 @warning 
  - Does not guarantee valid image data.
  - Returns NULL for non-image formats.
  - Images should be requeued to prevent starvation of the
    acquisition engine.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IImage
  - Arena::IDevice::StartStream
  - Arena::IDevice::StopStream
  - Arena::IDevice::RequeueBuffer
  - Arena::IDevice::GetBuffer
  - Arena::IImage::IsIncomplete
  - Arena::ImageFactory::Create

</member>
        <member name="M:Arena.IDevice.StopStream">
 @fn virtual void StopStream()

 @return 
  - none

 <B> StopStream </B> stops the device from streaming image/chunk data
 (Arena::IBuffer, Arena::IImage, Arena::IChunkData) and cleans up the
 stream. The stream must be stopped when streaming is no longer needed.

 <B> StopStream </B> reverses the set up of the stream:
  - Stops the worker thread.
  - Shuts down the stream channel socket.
  - Executes the 'AcquisitionStop' feature in order to stop the
    device from sending packets.
  - Has the device unlock features that had been locked for streaming
    (e.g. 'Width', 'Height').
  - Revokes all buffers and cleans up their allocated memory.

 Buffers used internally are allocated when the stream has started
 (Arena::IDevice::StartStream) and deallocated when it has stopped
 (Arena::IDevice::StopStream). If an image has been retrieved
 (Arena::IDevice::GetImage), it can be copied (Arena::ImageFactory::Copy)
 or saved before stopping the stream. If image data were accessed after
 stopping the stream, the memory would be deallocated and the behavior
 undefined.

 \code{.cpp}
 	// retrieving an image and copying it before requeuing its buffer and stopping the stream
 	{
 		Arena::IImage* pImage = pDevice-&gt;GetImage();
 		Arena::IImage* pCopiedImage = Arena::ImageFactory::Copy(pImage);
 		
 		pDevice-&gt;RequeueBuffer(pImage);
 		pDevice-&gt;StopStream();
 	}
 \endcode

 @warning 
  - Stream must be stopped.
  - Updates write access to certain nodes.
  - Disallows retrieval of image/chunk data from device.
  - Deallocates image/chunk data that has not been copied to memory
    or disk.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer
  - Arena::IImage
  - Arena::IChunkData
  - Arena::IDevice::StartStream
  - Arena::IDevice::StopStream
  - Arena::IDevice::GetImage
  - Arena::ImageFactory::Copy

</member>
        <member name="M:Arena.IDevice.StartStream(System.UInt64)">
 @fn virtual void StartStream(size_t numBuffers = 10)

 @param numBuffers
  - Type: size_t
  - Default: 10
  - Number of internal buffers to use in the acquisition engine

 @return 
  - none

 <B> StartStream </B> causes the device to begin streaming image/chunk
 data
 (Arena::IBuffer, Arena::IImage, Arena::IChunkData). It must be called
 before image or chunk data buffers are retrieved
 (Arena::IDevice::GetBuffer, Arena::IDevice::GetImage). The stream must be
 stopped (Arena::IDevice::StopStream) when no longer needed.

 Basically, calling <B> StartStream </B> prepares and starts the
 underlying streaming engine. The streaming engine primarily consists
 of a number of buffers, an input and an output queue, and a worker
 thread to run off of the main thread. All buffers are first placed in
 the input queue. When a buffer reaches its turn, it is filled with
 data. Once complete, it is moved to the output queue. At this point a
 buffer might be retrieved by the user (Arena::IDevice::GetBuffer,
 Arena::IDevice::GetImage) and then returned to the input queue
 (Arena::IDevice::RequeueBuffer).

 More specifically, <B> StartStream </B>:
  - Allocates and announces a number of buffers according to the
    numBuffers parameter.
  - Pushes all buffers to the input queue.
  - Opens a stream channel socket.
  - Configures the IP and port on the device.
  - Fires a dummy packet to help with firewalls.
  - Requests a test packet to ensure configured packet size is
    appropriate.
  - Starts the worker thread and begins listening for packets related
    to the acquisition engine.
  - Has the device lock out certain features (e.g. 'Width', 'Height')
    that cannot be changed during the stream.
  - Executes the 'AcquisitionStart' feature in order to have the
    device start sending packets.

 \code{.cpp}
 	// setting width and height to max before starting the stream
 	// because these features are locked out while streaming
 	{
 		GenApi::INodeMap* pNodeMap = pDevice-&gt;GetNodeMap();
 		
 		GenApi::CIntegerPtr pWidth = pNodeMap-&gt;GetNode("Width");
 		pWidth-&gt;SetValue(pWidth-&gt;GetMax());
 		
 		GenApi::CIntegerPtr pHeight = pNodeMap-&gt;GetNode("Height");
 		pHeight-&gt;SetValue(pHeight-&gt;GetMax());
 		
 		pDevice-&gt;StartStream();
 	}
 \endcode

 All stream configurations must be completed before starting the
 stream. This includes the buffer handling mode
 ('StreamBufferHandlingMode') found on the stream node map
 (Arena::IDevice::GetTLStreamNodeMap). Setting the buffer handling mode
 configures what the streaming engine does with buffers as they are
 filled and moved between queues. There are three modes to choose from:
  - 'OldestFirst' is the default buffer handling mode. As buffers are
    filled with data, they get pushed to the back of the output queue.
    When a buffer is requested (Arena::IDevice::GetBuffer,
    Arena::IBuffer::GetImage), the buffer at the front of the queue is
    returned. If there are no input buffers available, the next
    incoming image is dropped and the lost frame count
    ('StreamLostFrameCount') is incremented.
  - 'OldestFirstOverwrite' is similar to 'OldestFirst' except for
    what happens when there are no input buffers. Instead of dropping
    an image, the oldest buffer in the output queue gets returned to
    the input queue so that its data can be overwritten.
  - 'NewestOnly' only ever has a single buffer in the output queue.
    If a second buffer gets placed into the output queue, the older
    buffer gets returned to the back of the input queue. If there are
    no input buffers available, the next image is dropped and the lost
    frame count
    ('StreamLostFrameCount') is incremented.

 \code{.cpp}
 	// setting the buffer handling mode to 'NewestOnly' before starting the stream
 	{
 		GenApi::INodeMap* pStreamNodeMap = pDevice-&gt;GetTLStreamNodeMap();
 		
 		GenApi::CEnumerationPtr pStreamBufferHandlingMode = pStreamNodeMap-&gt;GetNode("StreamBufferHandlingMode");
 		GenApi::CEnumEntryPtr pNewestOnly = pStreamBufferHandlingMode-&gt;GetNode("NewestOnly");
 		pStreamBufferHandlingMode-&gt;SetIntValue(pNewOnly-&gt;GetValue());
 		
 		pDevice-&gt;StartStream()
 	}
 \endcode

 @warning 
  - Stream must already be configured prior to call.
  - Updates write access to certain nodes.
  - May only be called once per stream without stopping.
  - Stream must be stopped.
  - May throw GenICam::GenericException or other derived exception.
  - Minimum number of buffers is 1.

 @see 
  - Arena::IBuffer
  - Arena::IImage
  - Arena::IChunkData
  - Arena::IDevice::GetBuffer
  - Arena::IDevice::GetImage
  - Arena::IDevice::StopStream
  - Arena::IDevice::RequeueBuffer
  - Arena::IDevice::GetTLStreamNodeMap
  - Arena::IBuffer::GetImage

</member>
        <member name="M:Arena.IDevice.IsConnected">
 @fn virtual bool IsConnected()

  - Type: bool
  - Indicates if device is connected

 <B> IsConnected </B> returns true if a device has been opened and
 maintains a valid communication socket. The device is opened when
 (Arena::ISystem::CreateDevice) is called. If the connection to the device
 is lost this will return false.

 More specifically, for GigE devices, this flag is set to false when
 the Arena is not able to refresh the heartbeat on the device. If an
 operation times out more than 3 times, the device will be flagged as
 not connected.

 @see 
  - Arena::ISystem::CreateDevice

</member>
        <member name="T:Arena._EBayerAlgorithm">
 @typedef EBayerAlgorithm

 The <B> EBayerAlgorithm </B> enum represents different algorithms for
 interpreting Bayer patterns. Provide this enum when converting an image
 from any Bayer pattern (Arena::ImageFactory::Create).

 The enum values and their descriptions
  - DirectionalInterpolation
    - Description: Algorithm that averages nearest neighbours (faster)
  - AdaptiveHomogeneityDirected
    - Description: Adaptive algorithm that uses directional data (slower,
      more accurate coloring)
  - _UndefinedAlgorithm
    - Description: Object not yet initialized

 @see 
  - Arena::ImageFactory::Create

</member>
        <member name="T:Arena._EPixelEndianness">
 @typedef EPixelEndianness

 The <B> EPixelEndianness </B> enum represents the endianness of an image's
 multi-byte pixels. This enum is returned from images
 (Arena::IImage::GetPixelEndianness).

 The enum values and their descriptions:
  - PixelEndiannessUnknown
    - Value: 0
    - Description: Unknown pixel endianness
  - PixelEndiannessLittle
    - Value: 1
    - Description: Little endian
  - PixelEndiannessBig
    - Value: 2
    - Description: Big endian

 @see 
  - Arena::IImage::GetPixelEndianness

</member>
        <member name="T:Arena._EBufferPayloadType">
 @typedef EBufferPayloadType

 The <B> EBufferPayloadType </B> enum represents the different types of
 GVSP data that can be acquired by the acquisition engine. This enum is
 returned from:
  - buffers (Arena::IBuffer::GetPayloadType)
  - images (Arena::IImage::GetPayloadType)
  - chunk data (Arena::IChunkData::GetPayloadType)

 The enum values and their descriptions:
  - BufferPayloadTypeImage
    - Value: 0x0001
    - Description: Image data only
  - BufferPayloadTypeImageExtendedChunk
    - Value: 0x4001
    - Description: Image data extended with chunk data
  - BufferPayloadTypeChunkData
    - Value: 0x0004
    - Description: Chunk data only; image data may be present as chunk
	- BufferPayloadTypeCompressedImage
	  - Value: 0x1001
	  - Description: Compressed image data only
	- BufferPayloadTypeCompressedImageExtendedChunk
	  - Value: 0x1002
	  - Description: Compressed image data extended with chunk data

 @see 
  - Arena::IBuffer::GetPayloadType
  - Arena::IImage::GetPayloadType
  - Arena::IChunkData::GetPayloadType

</member>
        <member name="T:Arena._ENumBufferFlags">
 @typedef ENumBufferFlags

 The <B> ENumBufferFlags </B> predefined number of buffers options for the
 stream.

 The enum values and their descriptions:
  - NumBuffersAuto
    - Value: 0xFFFFFFFF
    - Description: Auto calculate numBuffers based on max throughput

</member>
        <member name="T:Arena.EvsRawTriggerEvent">
 @struct EvsRawTriggerEvent

 This structure represents a EVT 3.0 external trigger output (EXT_TRIGGER) event received by the camera

 Member 'id' contains the trigger channel id
 Member 'polarity' contains the trigger edge polarity (0: falling edge, 1: rising edge)
 Member 'timestamp' contains the timestamp for the trigger event
 Member 'gvspBlockId' contains the corresponding GVSP BlockId in which the trigger event was received
 
 This struct is returned from Arena::IDevice::GetNextEvsTriggerEvent
 
 @see 
  - Arena::IDevice::GetNextEvsTriggerEvent

</member>
        <member name="T:Arena.EvsRawDecodedEvent">
 @struct EvsRawDecodedEvent

 This structure represents one EVT 3.0 event in a event camera buffer in the RawDecoded format 

 Member 'x' contains the x-ccordinate for the event
 Member 'y' contains the y-ccordinate for the event
 Member 'p' contains the polarity for the event
 Member 't' contains the timestamp for the event
 

</member>
        <member name="T:Arena.LucidXYTPPixel">
 @struct LucidXYTPPixel

 This structure represents one EVT 3.0 event in a event camera buffer in the XYTPFrame format 

 Member 'x' contains the x pixel coordinate of the CD event
 Member 'y' contains the y pixel coordinate of the CD event
 Member 't' contains the timestamp of the CD event
 Member 'p' contains the polarity of the event
 

</member>
        <member name="M:Arena.IImage.Dispose">
 @fn virtual ~IImage()

 A destructor

</member>
        <member name="M:Arena.IImage.VerifyCRC">
 @fn virtual bool VerifyCRC()

 @return 
  - Type: bool
  - True if the calculated CRC value equals the one sent from the
    device
  - Otherwise, false

 <B> VerifyCRC </B> calculates the CRC of an image's data and verifies
 it against the CRC value sent from the device. This helps verify that
 no data has been changed or missed during transmission. This function
 calls a global helper function to calculate the CRC
 (Arena::CalculateCRC32).

 A CRC is performed by running a set of calculations on a dataset both
 before and after a transmission. The two calculated values are then
 compared for equality. If the values are the same, then the
 transmission is deemed successful; if different, then something in the
 transmission went wrong.

 A device can be set to send a CRC value by enabling its chunk data
 setting.

 \code{.cpp}
 	// Enable chunk data and the CRC chunk
 	{
 		GenApi::INodeMap* pNodeMap = pDevice-&gt;GetNodeMap();
 		
 		GenApi::CBooleanPtr pChunkModeActive = pNodeMap-&gt;GetNode("ChunkModeActive");
 		pChunkModeActive-&gt;SetValue(true);
 		
 		GenApi::CEnumerationPtr pChunkSelector = pNodeMap-&gt;GetNode("ChunkSelector");
 		GenApi::CEnumEntryPtr pCRC = pChunkSelector-&gt;GetEntryByname("CRC");
 		pChunkSelector-&gt;SetIntValue(pCRC-&gt;GetValue());
 		
 		GenApi::CBooleanPtr pChunkEnable = pNodeMap-&gt;GetNode("ChunkEnable");
 		pChunkEnable-&gt;SetValue(true);
 	}
 \endcode

 The data can then be checked by verifying the CRC.

 \code{.cpp}
 	// Verifying a buffer's data
 	{
 		Arena::IImage* pImage = pDevice-&gt;GetImage(timeout);
 		if (!pImage-&gt;VerifyCRC())
 		{
 			// data not complete
 		}
 	}
 \endcode

 @warning 
  - May throw GenICam::GenericException or other derived exception.
  - Throws an exception if chunk data disabled or not present, or if CRC chunk
    disabled.

 @see 
  - Arena::CalculateCRC
  - Arena::IImage

</member>
        <member name="M:Arena.IImage.DataLargerThanBuffer">
 @fn virtual bool DataLargerThanBuffer()

 @return 
  - Type: bool
  - True if the payload is larger than the buffer
  - Otherwise, false

 <B> DataLargerThanBuffer </B> returns whether or not a buffer's
 payload data is too large for the buffer.

 A buffer may be missing data if the buffer to hold the data is too
 small. This happens when the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer) does not match the expected data
 size ('PayloadSize'). This function will also return true when
 checking whether the data is larger than the buffer.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer

</member>
        <member name="M:Arena.IImage.IsIncomplete">
 @fn virtual bool IsIncomplete()

 @return 
  - Type: bool
  - True if the data is incomplete
  - Otherwise, false

 <B> IsIncomplete </B> returns whether or not a buffer's payload data
 is complete.

 Error handling may be required if the data is
 incomplete. An incomplete image signifies that the data size
 (Arena::IBuffer::GetSizeFilled) does not match the expected data size
 ('PayloadSize'). This is either due to missed packets or a small buffer.

 The number of missed packets may be discovered through the stream node
 map
 (Arena::IDevice::GetTLStreamNodeMap). The missed packet count feature
 ('StreamMissedPacketCount') is a cumulative count of all missed packets,
 and does not necessarily reflect the number of missed packets for any
 given buffer.

 A buffer may be missing data if the buffer to hold the data is too
 small. This happens when the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer) does not match the expected data
 size ('PayloadSize'). This function will also return true when
 checking whether the data is larger than the buffer
 (Arena::IBuffer::DataLargerThanBuffer).

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeFilled
  - Arena::IDevice::GetTLStreamNodeMap
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IBuffer::DataLargerThanBuffer

</member>
        <member name="M:Arena.IImage.AsChunkData">
 virtual IChunkData* AsChunkData()

 @return 
 - Type: Arena::IChunkData 
 - Pointer to the original object cast to chunk data
 - Null on failure

 <B> AsChunkData </B> casts the image to chunk data
 (Arena::IChunkData). This is only possible if the payload contains
 chunk data.

 @warning 
 - Causes undefined behaviour if buffer requeued.

 @see 
 - Arena::IChunkData 
 - Arena::IBuffer::HasChunkData

</member>
        <member name="M:Arena.IImage.HasChunkData">
 @fn virtual bool HasChunkData()

 @return 
  - Type: bool
  - True if the payload has chunk data
  - Otherwise, false

 <B> HasChunkData </B> returns whether or not a payload can be
 interpreted as chunk data.

 <B> HasChunkData </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeChunkData
  - Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk

 It returns false if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeImage

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IImage.HasImageData">
 @fn virtual bool HasImageData()

 @return 
  - Type: bool
  - True if the payload has image data
  - False if the payload has image packaged as chunk data
  - Otherwise, false

 <B> HasImageData </B> returns whether or not a payload can be
 interpreted as image data. Calling <B> HasImageData </B> from an image
 returns true.

 <B> HasImageData </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeImage
  - Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk

 It returns false if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeChunkData

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IImage.GetPayloadType">
 @fn virtual size_t GetPayloadType()

 @return 
  - Type: size_t
  - Represents: enum Arena::EBufferPayloadType
  - Type of payload data

 <B> GetPayloadType </B> returns a buffer's payload type
 (Arena::EBufferPayloadType), as defined in the GigE Vision specification.

 The payload type indicates how to interpret the data stored in the
 buffer
 (Arena::IBuffer::GetData). LUCID devices may provide three ways to
 interpret the data:
  - As an image (Arena::EBufferPayloadType::BufferPayloadTypeImage)
  - As an image with chunk data appended to the end
    (Arena::EBufferPayloadType::BufferPayloadTypeImageExtended) 
  - As chunk data, which may or may not include image data as a chunk
  - (Arena::EBufferPayloadType::BufferPayloadTypeChunkData)

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetData
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IImage.GetFrameId">
 @fn virtual uint64_t GetFrameId()

 @return 
  - Type: uint64_t
  - Frame ID of the image

 <B> GetFrameId </B> gets the frame ID, a sequential identifier for
 buffers.

 Frame IDs start at '1' and continue until 2^64-1
 (64-bit), at which point they roll over back to '1'. The frame ID should
 never be '0'.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

</member>
        <member name="M:Arena.IImage.GetSizeOfBuffer">
 @fn virtual size_t GetSizeOfBuffer()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the buffer

 <B> GetSizeOfBuffer </B> retrieves the size of the buffer.

 The size filled is often same as the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer), but not because they are one and the
 same. <B> GetSizeFilled </B> returns the number of bytes received
 whereas <B> GetSizeOfBuffer </B> returns the size of the buffer, which
 can either be allocated by the user or calculated by Arena
 (Arena::IDevice::GetNodeMap, 'PayloadSize').

 The payload size is calculated at the beginning of the stream and
 cannot be recalculated until the stream has stopped. Because of this,
 features that can affect payload size ('Width', 'Height',
 'PixelFormat') become unwritable when the stream has started.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.IImage.GetPayloadSize">
 @fn virtual size_t GetPayloadSize()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the intended payload

 <B> GetPayloadSize </B> retrieves the intended size of the payload.
 This is similar to the retrieved payload size
 (Arena::IBuffer::GetSizeFilled), but different in that missed data is
 included. This returns the same as the SFNC feature by the same name
 ('PayloadSize').

 @warning 
  - Causes undefined behavior if buffer requeued.

 @see 
  - Arena::IBuffer::GetSizeFilled

</member>
        <member name="M:Arena.IImage.GetSizeFilled">
 @fn virtual size_t GetSizeFilled()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the payload data

 <B> GetSizeFilled </B> retrieves the size of the data of a buffer,
 excluding transport layer protocol leaders.

 The size filled is often same as the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer), but not because they are one and the
 same. <B> GetSizeFilled </B> returns the number of bytes received
 whereas <B> GetSizeOfBuffer </B> returns the size of the buffer, which
 can either be allocated by the user or calculated by Arena
 (Arena::IDevice::GetNodeMap, 'PayloadSize').

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.IImage.GetData">
 @fn virtual const uint8_t* GetData()

 @return 
  - Type: const uint8_t*
  - Pointer to the payload data

 <B> GetData </B> returns a pointer to the beginning of the image's
 payload data. The payload may include chunk data.

 The returned data only includes payload data, not transport layer
 protocol leaders, which is handled internally. The pointer can be used
 in conjunction with size getters (Arena::IBuffer::GetSizeFilled) to
 read, process, and pass the data around. The data may include image
 data
 (Arena::IBuffer::HasImageData), chunk data (Arena::IBuffer::HasChunkData),
 or both.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeFilled
  - Arena::IBuffer::HasImageData
  - Arena::IBuffer::HasChunkData

</member>
        <member name="M:Arena.IImage.GetTimestampNs">
 @fn virtual uint64_t GetTimestampNs()

 @return 
  - Type: uint64_t
  - Unit: nanoseconds
  - Timestamp of the image in nanoseconds

 <B> GetTimestampNs </B> gets the timestamp of the image in
 nanoseconds. Images are self-describing, so the device does not need
 to be queried to get this information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the timestamp is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the timestamp is populated by the arguments.

 The image factory can create an image from another image
 (Arena::IImage) or from a minimal set of parameters (data, width,
 height, pixel format). If the image was created from parameters, the
 timestamp will be set to 0, no matter its original value.

 This is the same as the general timestamp call
 (Arena::IImage::GetTimestamp).

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory
  - Arena::IImage
  - Arena::IImage::GetTimestamp

</member>
        <member name="M:Arena.IImage.GetTimestamp">
 @fn virtual uint64_t GetTimestamp()

 @return 
  - Type: uint64_t
  - Unit: nanoseconds
  - Timestamp of the image in nanoseconds

 <B> GetTimestamp </B> gets the timestamp of the image in nanoseconds.
 Images are self-describing, so the device does not need to be queried
 to get this information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the timestamp is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the timestamp is populated by the arguments.

 The image factory can create an image from another image
 (Arena::IImage) or from a minimal set of parameters (data, width,
 height, pixel format). If the image was created from parameters, the
 timestamp will be set to 0, no matter its original value.

 This is the same as the nanosecond timestamp call
 (Arena::IImage::GetTimestampNs).

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory
  - Arena::IImage
  - Arena::IImage::GetTimestampNs

</member>
        <member name="M:Arena.IImage.GetPixelEndianness">
 @fn virtual int32_t GetPixelEndianness()

 @return 
  - Type: int32_t
  - Represents: enum Arena::EPixelEndianness
  - Endianness of the pixels of the image

 <B> GetPixelEndianness </B> gets the pixel endianness
 (Arena::EPixelEndianness) of the image. Images are self-describing, so the
 device does not need to be queried to get this information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the pixel endianness is populated by the acquisition
 engine payload leader. The device itself is not queried as this data
 is present in the image data. If the image was created by the image
 factory, the pixel endianness is populated by the arguments.

 The image factory can create an image from another image
 (Arena::IImage) or from a minimal set of parameters (data, width,
 height, pixel format). If the image was created from parameters, the
 pixel endianness will be set to 0
 (EPixelEndianness::PixelEndiannessUnknown), no matter its original
 value.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory
  - Arena::IImage
  - Arena::EPixelEndianness

</member>
        <member name="M:Arena.IImage.GetBitsPerPixel">
 @fn virtual size_t GetBitsPerPixel()

 @return 
  - Type: size_t
  - Unit: pixels
  - Bits per pixel of the image

 <B> GetBitsPerPixel </B> gets the number of bits per pixel of the
 image from the integer value of the pixel format (PfncFormat).
 Internally, a public helper function is called
 (Arena::GetBitsPerPixel).

 Pixel format values are determined by the PFNC (Pixel Format Naming
 Convention) specification. The PFNC assigns a name and number to each
 pixel format, helping to standardize pixel formats. The number of bits
 per pixel can be found in each integer at bytes 5 and 6 (mask
 0x00FF0000). The pixel format can be determined by the integer using
 the GetPixelFormatName function provided by the PFNC.

 @see 
  - Arena::GetBitsPerPixel

</member>
        <member name="M:Arena.IImage.GetPixelFormat">
 @fn virtual uint64_t GetPixelFormat()

 @return 
  - Type: uint64_t
  - Represents: enum PfncFormat
  - Pixel format of the image

 <B> GetPixelFormat </B> gets the pixel format (PfncFormat) of the
 image, as defined by the PFNC (Pixel Format Naming Convention). Images
 are self-describing, so the device does not need to be queried to get
 this information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the pixel format is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the pixel format is populated by the arguments.

 Pixel format values are determined by the PFNC (Pixel Format Naming
 Convention) specification. The PFNC assigns a name and number to each
 pixel format, helping to standardize pixel formats. The number of bits
 per pixel can be found in each integer at bytes 5 and 6 (mask
 0x00FF0000). The pixel format can be determined by the integer using
 the GetPixelFormatName function provided by the PFNC.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory

</member>
        <member name="M:Arena.IImage.GetPaddingY">
 @fn virtual size_t GetPaddingY()

 @return 
  - Type: size_t
  - Unit: pixels
  - Padding Y of the image

 <B> GetPaddingY </B> gets the padding of the image along the Y-axis.
 Images are self-describing, so the device does not need to be queried
 to get this information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the padding Y is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the padding Y is populated by the arguments.

 The image factory can create an image from another image
 (Arena::IImage) or from a minimal set of parameters (data, width,
 height, pixel format). If the image was created from parameters, the
 padding Y will be set to 0, no matter its original value.

 Padding Y specifically refers to the number of bytes padding the end
 of an image. This number will not affect the pitch/stride/step of an
 image.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory
  - Arena::IImage

</member>
        <member name="M:Arena.IImage.GetPaddingX">
 @fn virtual size_t GetPaddingX()

 @return 
  - Type: size_t
  - Unit: pixels
  - Padding X of the image

 <B> GetPaddingX </B> gets the padding of the image along the X-axis.
 Images are self-describing, so the device does not need to be queried
 to get this information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the padding X is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the padding X is populated by the arguments.

 The image factory can create an image from another image
 (Arena::IImage) or from a minimal set of parameters (data, width,
 height, pixel format). If the image was created from parameters, the
 padding X will be set to 0, no matter its original value.

 Padding X specifically refers to the number of bytes padding the end
 of each line. This number will affect the pitch/stride/step of an
 image.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory
  - Arena::IImage

</member>
        <member name="M:Arena.IImage.GetOffsetY">
 @fn virtual size_t GetOffsetY()

 @return 
  - Type: size_t
  - Unit: pixels
  - Offset Y of the image

 <B> GetOffsetY </B> gets the offset of the image along the Y-axis.
 Images are self-describing, so the device does not need to be queried
 to get this information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the offset Y is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the offset Y is populated by the arguments.

 The image factory can create an image from another image
 (Arena::IImage) or from a minimal set of parameters (data, width,
 height, pixel format). If the created from parameters, the offset Y
 will be set to 0, no matter its original value.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory
  - Arena::IImage

</member>
        <member name="M:Arena.IImage.GetOffsetX">
 @fn virtual size_t GetOffsetX()

 @return 
  - Type: size_t
  - Unit: pixels
  - Offset X of the image

 <B> GetOffsetX </B> gets the offset of the image along the X-axis.
 Images are self-describing, so the device does not need to be queried
 to get this information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the offset X is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the offset X is populated by the arguments.

 The image factory can create an image from another image
 (Arena::IImage) or from a minimal set of parameters (data, width,
 height, pixel format). If the image is created from parameters, the
 offset X will be set to 0, no matter its original value.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory
  - Arena::IImage

</member>
        <member name="M:Arena.IImage.GetHeight">
 @fn virtual size_t GetHeight()

 @return 
  - Type: size_t
  - Unit: pixels
  - Height of the image

 <B> GetHeight </B> gets the height of the image. Images are
 self-describing, so the device does not need to be queried to get this
 information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the height is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the height is populated by the arguments.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory

</member>
        <member name="M:Arena.IImage.GetWidth">
 @fn virtual size_t GetWidth()

 @return 
  - Type: size_t
  - Unit: pixels
  - Width of the image

 <B> GetWidth </B> gets the width of the image in pixels. Images are
 self-describing, so the device does not need to be queried to get this
 information.

 Images are either retrieved from a device (Arena::IDevice) or created
 by the image factory (Arena::ImageFactory). If the image was retrieved
 from a device, the width is populated by the acquisition engine
 payload leader. The device itself is not queried as this data is
 present in the image data. If the image was created by the image
 factory, the width is populated by the arguments.

 @warning 
  - Causes undefined behaviour if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory

</member>
        <member name="T:Arena.IImage">
 @class IImage

 An interface to an image object

 Images are the most common form of data retrieved from the stream engine.
 They are retrieved and requeued via devices (Arena::IDevice) as well as
 created, copied, and converted via the image factory
 (Arena::ImageFactory).

 \code{.cpp}
 	// retrieving an image after starting the stream
 	// requeuing it before stopping the stream
 	{
 		pDevice-&gt;StartStream();
 		Arena::IImage* pImage = pDevice-&gt;GetImage(100);
 		// ...
 		pDevice-&gt;RequeueBuffer(pImage);
 		pDevice-&gt;StopStream();
 	}
 \endcode

 Along with the functionality of its parent class (Arena::IBuffer), images
 provide access to additional information particular to images. This
 includes:
  - Size information (Arena::IImage::GetWidth, Arena::IImage::GetHeight
  - Offsets (Arena::IImage::GetOffsetX, Arena::IImage::GetOffsetY)
  - Padding (Arena::IImage::GetPaddingX, Arena::IImage::GetPaddingY)
  - Pixel information (Arena::IImage::GetPixelFormat,
    Arena::IImage::GetPixelEndianness)
  - Timestamps (Arena::IImage::GetTimestamp,
    Arena::IImage::GetTimestampNs)

 It is important to note that images retrieved from the camera must be
 requeued (Arena::IDevice::RequeueBuffer) whereas images created using the
 image factory must be destroyed (Arena::ImageFactory::Destroy).

 \code{.cpp}
 	// retrieving an image, copying it, requeuing its buffer, and destroying the copy
 	{
 		Arena::IImage* pRetrievedImage = pDevice-&gt;GetImage(timeout);
 		Arena::IImage* pCopiedImage = Arena::ImageFactory::Create(pImage-&gt;GetData(), pImage-&gt;GetHeight(), pImage-&gt;GetWidth(), pImage-&gt;GetBitsPerPixel(), pImage-&gt;GetImageLength(), pImage-&gt;GetPixelFormat());
 		pDevice-&gt;RequeueBuffer(pRetrievedImage);
 		// ...
 		Arena::ImageFactory::Destroy(pCopiedImage);
 	}
 \endcode

 @warning 
  - Should be requeued if retrieved from the device.
  - Must be destroyed if created by the image factory.
  - Properties of images from the stream engine are lazily instantiated.
  - Properties of images from the image factory may be unavailable.

 @see 
  - Arena::IDevice
  - Arena::ImageFactory
  - Arena::IImage
  - Arena::IBuffer

</member>
        <member name="M:Arena.IBuffer.Dispose">
 @fn virtual ~IBuffer()

 A destructor

</member>
        <member name="M:Arena.IBuffer.VerifyCRC">
 @fn virtual bool VerifyCRC()

 @return 
  - Type: bool
  - True if the calculated CRC value equals the one sent from the
    device
  - Otherwise, false

 <B> VerifyCRC </B> calculates the CRC of a buffer's data and verifies
 it against the CRC value sent from the device. This helps verify that
 no data has been changed or missed during a transmission. This
 function calls a global helper function to calculate the CRC
 (Arena::CalculateCRC32).

 A CRC is performed by running a set of calculations on a dataset both
 before and after a transmission. The two calculated values are then
 compared for equality. If the values are the same, then the
 transmission is deemed successful; if different, then something in the
 transmission went wrong.

 A device can be set to send a CRC value by enabling its chunk data
 setting.

 \code{.cpp}
 	// Enable chunk data and the CRC chunk
 	{
 		GenApi::INodeMap* pNodeMap = pDevice-&gt;GetNodeMap();
 		
 		GenApi::CBooleanPtr pChunkModeActive = pNodeMap-&gt;GetNode("ChunkModeActive");
 		pChunkModeActive-&gt;SetValue(true);
 		
 		GenApi::CEnumerationPtr pChunkSelector = pNodeMap-&gt;GetNode("ChunkSelector");
 		GenApi::CEnumEntryPtr pCRC = pChunkSelector-&gt;GetEntryByname("CRC");
 		pChunkSelector-&gt;SetIntValue(pCRC-&gt;GetValue());
 		
 		GenApi::CBooleanPtr pChunkEnable = pNodeMap-&gt;GetNode("ChunkEnable");
 		pChunkEnable-&gt;SetValue(true);
 	}
 \endcode

 The data can then be checked by verifying the CRC.

 \code{.cpp}
 	// Verifying a buffer's data
 	{
 		Arena::IBuffer* pBuffer = pDevice-&gt;GetBuffer(timeout);
 		if (!pBuffer-&gt;VerifyCRC())
 		{
 			// data not complete
 		}
 	}
 \endcode

 @warning 
  - May throw GenICam::GenericException or other derived exception.
  - Throws an exception if chunk data disabled or not present, or if CRC chunk
    disabled.

 @see 
  - Arena::CalculateCRC
  - Arena::IBuffer

</member>
        <member name="M:Arena.IBuffer.DataLargerThanBuffer">
 @fn virtual bool DataLargerThanBuffer()

 @return 
  - Type: bool
  - True if the payload is larger than the buffer
  - Otherwise, false

 <B> DataLargerThanBuffer </B> returns whether or not a buffer's
 payload data is too large for the buffer.

 A buffer may be missing data if the buffer to hold the data is too
 small. This happens when the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer) does not match the expected data
 size (Arena::IDevice::GetTLStreamNodeMap, 'PayloadSize'). This
 function will also return true when checking whether the data is
 larger than the buffer.

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IDevice::GetTLStreamNodeMap

</member>
        <member name="M:Arena.IBuffer.IsIncomplete">
 @fn virtual bool IsIncomplete()

 @return 
  - Type: bool
  - True if the data is incomplete
  - Otherwise, false

 <B> IsIncomplete </B> returns whether or not the payload is complete.

 Error handling may be required if the data is
 incomplete. An incomplete image signifies that the data size
 (Arena::IBuffer::GetSizeFilled) does not match the expected data size
 (Arena::IDevice::GetTLStreamNodeMap, 'PayloadSize'). This is either due to
 missed packets or a small buffer.

 The number of missed packets may be discovered through the stream node
 map
 (Arena::IDevice::GetTLStreamNodeMap). The missed packet count feature
 (Arena::IDevice::GetTLStreamNodeMap, 'StreamMissedPacketCount') is a
 cumulative count of all missed packets, and does not necessarily
 reflect the number of missed packets for any given buffer.

 A buffer may be missing data if the buffer to hold the data is too
 small. This happens when the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer) does not match the expected data
 size (Arena::IDevice::GetTLStreamNodeMap, 'PayloadSize'). This
 function will also return true when checking whether the data is
 larger than the buffer (Arena::IBuffer::DataLargerThanBuffer).

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeFilled
  - Arena::IDevice::GetTLStreamNodeMap
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IBuffer::DataLargerThanBuffer

</member>
        <member name="M:Arena.IBuffer.AsCompressedImage">
 @fn virtual ICompressedImage* AsCompressedImage()

 @return 
  - Type: Arena::ICompressedImage*
  - Pointer to the original object cast to a compressed image
  - Null on failure

 <B> AsCompressedImage </B> casts the buffer to a compressed image
 (Arena::ICompressedImage). This is only possible if the payload
 contains compressed image data.

 @warning 
  - Causes undefined behavior if buffer requeued.

 @see 
  - Arena::ICompressedImage

</member>
        <member name="M:Arena.IBuffer.AsChunkData">
 @fn virtual IChunkData* AsChunkData()

 @return 
  - Type: Arena::IChunkData*
  - Pointer to the original object cast to chunk data
  - Null on failure

 <B> AsChunkData </B> casts the buffer to a chunk data
 (Arena::IChunkData). This is only possible if the payload contains
 chunk data.

 @warning 
  - Causes undefined behavior if buffer requeued.

 @see 
  - Arena::IChunkData

</member>
        <member name="M:Arena.IBuffer.AsImage">
 @fn virtual IImage* AsImage()

 @return 
  - Type: Arena::IImage*
  - Pointer to the original object cast to an image
  - Null on failure

 <B> AsImage </B> casts the buffer to an image (Arena::IImage). This is
 only possible if the payload contains image data.

 @warning 
  - Causes undefined behavior if buffer requeued.

 @see 
  - Arena::IImage

</member>
        <member name="M:Arena.IBuffer.IsCompressedImage">
 @fn virtual bool IsCompressedImage()

 @return 
  - Type: bool
  - True if the payload has compressed data
  - Otherwise, false

 <B> IsCompressedImage </B> returns whether or not a buffer's payload that
 may be interpreted as a compressed image.

 <B> IsCompressedImage </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeCompressedImage
  - Arena::EBufferPayloadType::BufferPayloadTypeCompressedImageExtendedChunk

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IBuffer.HasChunkData">
 @fn virtual bool HasChunkData()

 @return 
  - Type: bool
  - True if the payload has chunk data
  - Otherwise, false

 <B> HasChunkData </B> returns whether or not a buffer's payload that
 may be interpreted as chunk data.

 <B> HasChunkData </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeChunkData
  - Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk
  - Arena::EBufferPayloadType::BufferPayloadTypeCompressedImageExtendedChunk

 It returns false if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeImage
  - Arena::EBufferPayloadType::BufferPayloadTypeCompressedImage

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IBuffer.HasImageData">
 @fn virtual bool HasImageData()

 @return 
  - Type: bool
  - True if the payload has image data
  - False if the payload has image data packaged as chunk data
  - Otherwise, false

 <B> HasImageData </B> returns whether or not a buffer's payload has
 data that may be interpreted as image data.

 <B> HasImageData </B> returns true if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeImage
  - Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk

 It returns false if the payload type is:
  - Arena::EBufferPayloadType::BufferPayloadTypeChunkData
  - Arena::EBufferPayloadType::BufferPayloadTypeCompressedImage
  - Arena::EBufferPayloadType::BufferPayloadTypeCompressedImageExtendedChunk

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.
  - Returns false if image data is packaged as chunk data.

 @see 
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IBuffer.GetPayloadType">
 @fn virtual size_t GetPayloadType()

 @return 
  - Type: size_t
  - Represents: enum Arena::EBufferPayloadType
  - Type of payload data

 <B> GetPayloadType </B> returns a buffer's payload type
 (Arena::EBufferPayloadType), as defined by the GigE Vision specification.

 The payload type indicates how to interpret the data stored in the
 buffer
 (Arena::IBuffer::GetData). LUCID devices may provide three ways to
 interpret the data:
  - As an image (Arena::EBufferPayloadType::BufferPayloadTypeImage)
  - As an image with chunk data appended to the end
    (Arena::EBufferPayloadType::BufferPayloadTypeImageExtendedChunk) 
  - As chunk data, which may or may not include image data as a chunk
  - (Arena::EBufferPayloadType::BufferPayloadTypeChunkData) 
  - As a compressed image
    (Arena::EBufferPayloadType::BufferPayloadTypeCompressedImage)
  - As a compressed image with chunk data appended to the end
    (Arena::EBufferPayloadType::BufferPayloadTypeCompressedImageExtendedChunk)

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetData
  - Arena::EBufferPayloadType

</member>
        <member name="M:Arena.IBuffer.GetFrameId">
 @fn virtual uint64_t GetFrameId()

 @return 
  - Type: uint64_t
  - Frame ID

 <B> GetFrameId </B> gets the frame ID, a sequential identifier for
 buffers.

 Frame IDs start at '1' and continue until 2^64-1
 (64-bit), at which point they roll over back to '1'. The frame ID should
 never be '0'.

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.IBuffer.GetSizeOfBuffer">
 @fn virtual size_t GetSizeOfBuffer()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the buffer

 <B> GetSizeOfBuffer </B> retrieves the size of a buffer.

 The size filled is often same as the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer), but not because they are one and the
 same. <B> GetSizeFilled </B> returns the number of bytes received
 whereas <B> GetSizeOfBuffer </B> returns the size of the buffer, which
 can either be allocated by the user or calculated by Arena
 (Arena::IDevice::GetNodeMap, 'PayloadSize').

 The payload size is calculated at the beginning of the stream and
 cannot be recalculated until the stream has stopped. Because of this,
 features that can affect payload size ('Width', 'Height',
 'PixelFormat') become unwritable when the stream has started.

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.IBuffer.GetPayloadSize">
 @fn virtual size_t GetPayloadSize()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the intended payload

 <B> GetPayloadSize </B> retrieves the intended size of the payload.
 This is similar to the retrieved payload size
 (Arena::IBuffer::GetSizeFilled), but different in that missed data is
 included. This returns the same as the SFNC feature by the same name
 ('PayloadSize').

 @warning 
  - Causes undefined behavior if buffer requeued.

 @see 
  - Arena::IBuffer::GetSizeFilled

</member>
        <member name="M:Arena.IBuffer.GetSizeFilled">
 @fn virtual size_t GetSizeFilled()

 @return 
  - Type: size_t
  - Unit: bytes
  - Size of the received payload

 <B> GetSizeFilled </B> retrieves the size of the payload data,
 excluding transport layer protocol leaders. The payload data may
 include image data, chunk data, or both.

 The size filled is often same as the size of the buffer
 (Arena::IBuffer::GetSizeOfBuffer), but not because they are one and the
 same. <B> GetSizeFilled </B> returns the number of bytes received
 whereas <B> GetSizeOfBuffer </B> returns the size of the buffer, which
 can either be allocated by the user or calculated by Arena
 (Arena::IDevice::GetNodeMap, 'PayloadSize').

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::GetSizeOfBuffer
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.IBuffer.GetData">
 @fn virtual const uint8_t* GetData()

 @return 
  - Type: const uint8_t*
  - Pointer to the beginning of the payload data

 <B> GetData </B> retrieves a pointer to the buffer's payload data.
 This data may include image data, chunk data, or both. This also
 may include compressed data or compressed data with chunk data.

 To check the type of data returned, image
 (Arena::IBuffer::HasImageData), chunk
 (Arena::IBuffer::HasChunkData), compressed data
 (Arena::IBuffer::IsCompressedImage), can be checked for
 specifically, or the payload type (Arena::EBufferPayloadType) can
 be retrieved.

 The returned data only includes payload data, not transport layer
 protocol leaders, which is handled internally. The pointer can be used
 in conjunction with size getters (Arena::IBuffer::GetSizeFilled) to
 read, process, and pass the data around.

 @warning 
  - Causes undefined behavior if buffer requeued.
  - Properties lazily instantiated if buffer retrieved from device.
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IBuffer::HasImageData
  - Arena::IBuffer::HasChunkData
  - Arena::IBuffer::GetSizeFilled
  - Arena::EBufferPayloadType

</member>
        <member name="T:Arena.IBuffer">
 @class IBuffer

 An interface to a buffer object

 Buffers are the most generic form of acquisition engine data retrieved
 from a device. They are acquired and requeued via devices
 (Arena::IDevice).

 \code{.cpp}
 	// retrieving a buffer after starting the stream
 	// requeuing it before stopping the stream
 	{
 		pDevice-&gt;StartStream();
 		Arena::IBuffer* pBuffer = pDevice-&gt;GetBuffer(2000);
 		// ...
 		pDevice-&gt;RequeueBuffer(pBuffer);
 		pDevice-&gt;StopStream();
 	}
 \endcode

 Buffers are the base class of images (Arena::IImage) and chunk data
 (Arena::IChunkData). Information shared between both can be accessed in the
 buffer class:
  - buffer and payload information like payload
    (Arena::IBuffer::GetData), payload and buffer size
    (Arena::IBuffer::GetSizeFilled, Arena::IBuffer::GetSizeOfBuffer), and
 frame ID
    (Arena::IBuffer::GetFrameID) 
  - type information like payload type (Arena::IBuffer::GetPayloadType)
    and whether the payload has image and/or chunk data
    (Arena::IBuffer::HasImageData, Arena::IBuffer::HasChunkData) 
  - casting helpers (Arena::IBuffer::AsImage,
    Arena::IBuffer::AsChunkData)
  - error information (Arena::IBuffer::IsIncomplete,
  - Arena::IBuffer::DataLargerThanBuffer)

 Retrieving data as a buffer can be preferable to an image or chunk data,
 as it can allow data to be received and treated generically before further
 processing.

 \code{.cpp}
 	// processing image and chunk data only if they exist
 	{
 		Arena::IBuffer* pBuffer = pDevice-&gt;GetBuffer(2000);
 		if (pBuffer-&gt;HasImageData())
 		{
 			Arena::IImage* pImage = pBuffer-&gt;AsImage();
 			// ...
 		}
 		if (pBuffer-&gt;HasChunkData())
 		{
 			Arena::IChunkData* pChunkData = pBuffer-&gt;AsChunkData();
 			// ...
 		}
 		pDevice-&gt;RequeueBuffer(pBuffer);
 	}
 \endcode

 @warning 
  - Should be requeued; otherwise, acquisition engine may starve.
  - Properties are lazily instantiated from acquisition engine.

 @see 
  - Arena::IDevice
  - Arena::IBuffer
  - Arena::IImage
  - Arena::IChunkData

</member>
        <member name="M:Arena.CalculateCRC32(System.Byte!System.Runtime.CompilerServices.IsConst*,System.UInt64)">
 @fn int64_t CalculateCRC32(const uint8_t* pData, size_t nBytes)

 @param pData
  - Type: const uint8_t
  - A pointer to the data to use to calculate the CRC

 @param nBytes
  - Type: size_t
  - The size of the data

 @return 
  - Type: int64_t
  - The calculated CRC value

 <B> CalculateCRC32 </B> calculates a CRC value (cyclical redundancy check)
 on a dataset. This is used to check whether the dataset has been sent in
 its entirety.

 A CRC is performed by running a set of calculations on a dataset both
 before and after a transmission. The two calculated values are then
 compared for equality. If the values are the same, then the transmission
 is deemed successful; if different, then something in the transmission
 went wrong.

 A device can be set to send a CRC value by enabling its chunk data
 setting.

 \code{.cpp}
 	// Enable chunk data and the CRC chunk
 	{
 		GenApi::INodeMap* pNodeMap = pDevice-&gt;GetNodeMap();
 		
 		GenApi::CBooleanPtr pChunkModeActive = pNodeMap-&gt;GetNode("ChunkModeActive");
 		pChunkModeActive-&gt;SetValue(true);
 		
 		GenApi::CEnumerationPtr pChunkSelector = pNodeMap-&gt;GetNode("ChunkSelector");
 		GenApi::CEnumEntryPtr pCRC = pChunkSelector-&gt;GetEntryByname("CRC");
 		pChunkSelector-&gt;SetIntValue(pCRC-&gt;GetValue());
 		
 		GenApi::CBooleanPtr pChunkEnable = pNodeMap-&gt;GetNode("ChunkEnable");
 		pChunkEnable-&gt;SetValue(true);
 	}
 \endcode

 The CRC value can then be retrieved from a device.

 \code{.cpp}
 	// Retrieving CRC from chunk data, calculating it on the data, and comparing the two
 	{
 		Arena::IChunkData* pChunkData = pImage-&gt;AsChunkData();
 		GenApi::CIntegerPtr pChunkCRC = pChunkData-&gt;GetChunk("ChunkCRC");
 		int32_t crcFromDevice = pChunkCRC-&gt;GetValue();
 		
 		int32_t crcCalculated = CalculateCRC32(pImage-&gt;GetData(), pImage-&gt;SizeFilled());
 		if (crcFromDevice == crcCalculated)
 		{
 			// Image data is complete
 		}
 	}
 \endcode

 @warning 
  - May throw GenICam::GenericException or other derived exception.

 @see 
  - Arena::IChunkData

</member>
        <member name="M:Arena.InterfaceInfo.Dispose">
 @fn virtual ~InterfaceInfo()

 A destructor

</member>
        <member name="M:Arena.InterfaceInfo.#ctor">
 @fn InterfaceInfo()

 An empty constructor

 @warning 
  - Does not sufficiently initialize InterfaceInfo.

</member>
        <member name="M:Arena.InterfaceInfo.MacAddressStr">
 @fn virtual GenICam::gcstring MacAddressStr()

 @return 
  - Type: GenICam::gcstring
  - MAC address of the interface as a string

 <B> MacAddressStr </B> gets the MAC address of an interface on the
 host, returning it as a string.

 Both <B> MacAddress </B> and <B> MacAddressStr </B> represent the same
 MAC address. Where <B> MacAddress </B> returns the value in its raw
 integer format, <B> MacAddressStr </B> returns it as a more
 human-readable string:
  - <B> MacAddress </B>: 0x1C0FAF010101 
  - <B> MacAddressStr </B>: 1C:0F:AF:01:01:01

 @warning 
  - Represents the same information as Arena::InterfaceInfo::MacAddress.

 @see 
  - Arena::ISystem::GetInterfaces
  - Arena::ISystem::GetTLInterfaceNodeMap
  - Arena::InterfaceInfo::MacAddress

</member>
        <member name="M:Arena.InterfaceInfo.MacAddress">
 @fn virtual uint64_t MacAddress()

 @return 
  - Type: uint64_t
  - MAC address of the interface as an integer

 <B> MacAddress </B> gets the MAC address of an interface on the host,
 returning it as its raw integer value.

 Both <B> MacAddress </B> and <B> MacAddressStr </B> represent the same
 MAC address. Where <B> MacAddress </B> returns the value in its raw
 integer format, <B> MacAddressStr </B> returns it as a more
 human-readable string:
  - <B> MacAddress </B>: 0x1C0FAF010101 
  - <B> MacAddressStr </B>: 1C:0F:AF:01:01:01

 @warning 
  - Represents the same information as
    Arena::InterfaceInfo::MacAddressStr.

 @see 
  - Arena::ISystem::GetInterfaces
  - Arena::ISystem::GetTLInterfaceNodeMap
  - Arena::InterfaceInfo::MacAddressStr

</member>
        <member name="M:Arena.InterfaceInfo.SubnetMaskStr">
 @fn virtual GenICam::gcstring SubnetMaskStr()

 @return 
  - Type: GenICam::gcstring
  - Subnet mask of the device as a string

 <B> SubnetMaskStr </B> gets the subnet mask of an interface on the
 host, returning it as a string.

 Both <B> SubnetMask </B> and <B> SubnetMaskStr </B> represent the same
 subnet mask. Where <B> SubnetMask </B> returns the value in its raw
 integer format, <B> SubnetMaskStr </B> returns it as a more
 human-readable string:
  - <B> SubnetMask </B>: 0xFFFF0000 
  - <B> SubnetMaskStr </B>: 255.255.0.0

 @warning 
  - Represents the same information as Arena::InterfaceInfo::SubnetMask.

 @see 
  - Arena::ISystem::GetInterfaces
  - Arena::ISystem::GetTLInterfaceNodeMap
  - Arena::InterfaceInfo::SubnetMask

</member>
        <member name="M:Arena.InterfaceInfo.SubnetMask">
 @fn virtual uint32_t SubnetMask()

 @return 
  - Type: uint32_t
  - Subnet mask of the interface as an integer

 <B> SubnetMask </B> gets the subnet mask of an interface on the host,
 returning it as its raw integer value.

 Both <B> SubnetMask </B> and <B> SubnetMaskStr </B> represent the same
 subnet mask. Where <B> SubnetMask </B> returns the value in its raw
 integer format, <B> SubnetMaskStr </B> returns it as a more
 human-readable string:
  - <B> SubnetMask </B>: 0xFFFF0000 
  - <B> SubnetMaskStr </B>: 255.255.0.0

 An interface may have its IP address, subnet mask, and MAC Address
 checked through the main node map
 (Arena::ISystem::GetTLInterfaceNodeMap, 'GevInterfaceIPAddress',
 'GevInterfaceSubnetMask', 'GevInterfaceMACAddress').

 @warning 
  - Represents the same information as
    Arena::InterfaceInfo::SubnetMaskStr.

 @see 
  - Arena::ISystem::GetInterfaces
  - Arena::ISystem::GetTLInterfaceNodeMap
  - Arena::InterfaceInfo::SubnetMaskStr

</member>
        <member name="M:Arena.InterfaceInfo.IpAddressStr">
 @fn virtual GenICam::gcstring IpAddressStr()

 @return 
  - Type: GenICam::gcstring
  - IP address of the interface as a string

 <B> IpAddressStr </B> gets the IP address of an interface on the host,
 returning it as a string.

 Both <B> IpAddress </B> and <B> IpAddressStr </B> represent the same
 IP address. Where <B> IpAddress </B> returns the value in its raw
 integer format, <B> IpAddressStr </B> returns it as a more
 human-readable string:
  - <B> IpAddress </B>: 0xA9FE0101 
  - <B> IpAddressStr </B>: 169.254.1.1

 @warning 
  - Represents the same information as Arena::InterfaceInfo::IpAddress.
 

 @see 
  - Arena::ISystem::GetInterfaces
  - Arena::ISystem::GetTLInterfaceNodeMap
  - Arena::InterfaceInfo::IpAddress

</member>
        <member name="M:Arena.InterfaceInfo.IpAddress">
 @fn virtual uint32_t IpAddress()

 @return 
  - Type: uint32_t
  - IP address of the interface as an integer

 <B> IpAddress </B> gets the IP address of an interface on the host,
 returning it as its raw integer value.

 Both <B> IpAddress </B> and <B> IpAddressStr </B> represent the same
 IP address. Where <B> IpAddress </B> returns the value in its raw
 integer format, <B> IpAddressStr </B> returns it as a more
 human-readable string:
  - <B> IpAddress </B>: 0xA9FE0101 
  - <B> IpAddressStr </B>: 169.254.1.1
 
 An interface may have its IP address, subnet mask, and MAC Address
 checked through the main node map
 (Arena::ISystem::GetTLInterfaceNodeMap, 'GevInterfaceIPAddress',
 'GevInterfaceSubnetMask', 'GevInterfaceMACAddress')
 
 @warning 
  - Represents the same information as Arena::InterfaceInfo::IpAddressStr.

 @see 
  - Arena::ISystem::GetInterfaces
  - Arena::ISystem::GetTLInterfaceNodeMap
  - Arena::InterfaceInfo::IpAddressStr

</member>
        <member name="M:Arena.DeviceInfo.Dispose">
 @fn virtual ~DeviceInfo()

 A destructor

</member>
        <member name="M:Arena.DeviceInfo.#ctor">
 @fn DeviceInfo()

 An empty constructor

 @warning 
  - Does not sufficiently initialize DeviceInfo

</member>
        <member name="M:Arena.DeviceInfo.DeviceVersion">
 @fn virtual GenICam::gcstring DeviceVersion()

 @return 
  - Type: GenICam::gcstring
  - Firmware version of the device

 <B> DeviceVersion</B> retrieves the version of the device currently
 running on the device. For LUCID devices, this refers to firmware
 version.

</member>
        <member name="M:Arena.DeviceInfo.IsLLAConfigurationEnabled">
 @fn virtual bool IsLLAConfigurationEnabled()

 @return 
  - Type: bool
  - True if LLA enabled
  - Otherwise, false

 <B> IsLLAConfigurationEnabled </B> retrieves whether LLA is enabled on
 the device.

</member>
        <member name="M:Arena.DeviceInfo.IsPersistentIpConfigurationEnabled">
 @fn virtual bool IsPersistentIpConfigurationEnabled()

 @return 
  - Type: bool
  - True if persistent IP enabled
  - Otherwise, false

 <B> IsPersistentIpConfigurationEnabled </B> retrieves whether
 persistent IP is enabled on the device.

</member>
        <member name="M:Arena.DeviceInfo.IsDHCPConfigurationEnabled">
 @fn virtual bool IsDHCPConfigurationEnabled()

 @return 
  - Type: bool
  - True if DHCP enabled
  - Otherwise, false

 <B> IsDHCPConfigurationEnabled </B> retrieves whether DHCP is enabled
 on the device.

</member>
        <member name="M:Arena.DeviceInfo.UserDefinedName">
 @fn virtual GenICam::gcstring UserDefinedName()

 @return 
  - Type: GenICam::gcstring
  - User-defined name of a device

 <B> UserDefinedName </B> gets the user-defined name of a device. If
 supported, it is a customizable string with a maximum of 16 bytes that
 can be used to identify a device (Arena::IDevice::GetNodeMap,
 'DeviceUserID').

 The user-defined name returned by this getter is the same as the one
 received in the GigE Vision discovery acknowledgement.

 @warning 
  - Not necessarily supported

 @see 
  - Arena::IDevice::GetNodeMap

</member>
        <member name="M:Arena.DeviceInfo.MacAddressStr">
 @fn virtual GenICam::gcstring MacAddressStr()

 @return 
  - Type: GenICam::gcstring
  - MAC address of the device as a string

 <B> MacAddressStr </B> gets the MAC address of a device on the
 network, returning it as a string.

 Both <B> MacAddress </B> and <B> MacAddressStr </B> represent the same
 MAC address. Where <B> MacAddress </B> returns the value in its raw
 integer format, <B> MacAddressStr </B> returns it as a more
 human-readable string:
  - <B> MacAddress </B>: 0x1C0FAF010101 
  - <B> MacAddressStr </B>: 1C:0F:AF:01:01:01

 The MAC address returned by this getter is the same as the one
 received in the GigE Vision discovery acknowledgement.

 @warning 
  - Represents the same information as Arena::DeviceInfo::MacAddress.

 @see 
  - Arena::DeviceInfo::MacAddress

</member>
        <member name="M:Arena.DeviceInfo.MacAddress">
 @fn virtual uint64_t MacAddress()

 @return 
  - Type: uint64_t
  - MAC address of the device as an integer

 <B> MacAddress </B> gets the MAC address of a device on the network,
 returning it as its raw integer value.

 Both <B> MacAddress </B> and <B> MacAddressStr </B> represent the same
 MAC address. Where <B> MacAddress </B> returns the value in its raw
 integer format, <B> MacAddressStr </B> returns it as a more
 human-readable string:
  - <B> MacAddress </B>: 0x1C0FAF010101 
  - <B> MacAddressStr </B>: 1C:0F:AF:01:01:01

 The MAC address returned by this getter is the same as the one
 received in the GigE Vision discovery acknowledgement.

 @warning 
  - Represents the same information as Arena::DeviceInfo::MacAddressStr.

 @see 
  - Arena::DeviceInfo::MacAddressStr

</member>
        <member name="M:Arena.DeviceInfo.DefaultGatewayStr">
 @fn virtual GenICam::gcstring DefaultGatewayStr()

 @return 
  - Type: GenICam::gcstring
  - The default gateway

 <B> DefaultGateway </B> retrieves the default gateway of the device as
 a string.

</member>
        <member name="M:Arena.DeviceInfo.DefaultGateway">
 @fn virtual uint32_t DefaultGateway()

 @return 
  - Type: uint32_t
  - The default gateway

 <B> DefaultGateway </B> retrieves the default gateway of the device.

</member>
        <member name="M:Arena.DeviceInfo.SubnetMaskStr">
 @fn virtual GenICam::gcstring SubnetMaskStr()

 @return 
  - Type: GenICam::gcstring
  - Subnet mask of the device as a string

 <B> SubnetMaskStr </B> gets the subnet mask of a device on the
 network, returning it as a string.

 The GigE Vision specification only allows for IPv4 subnet masks. Both
 <B> SubnetMask </B> and <B> SubnetMaskStr </B> represent the same
 subnet mask. Where <B> SubnetMask </B> returns the value in its raw
 integer format, <B> SubnetMaskStr </B> returns it as a more
 human-readable string:
  - <B> SubnetMask </B>: 0xFFFF0000 
  - <B> SUbnetMaskStr </B>: 255.255.0.0

 A device may have its IP address, subnet mask, and default gateway
 assigned by LLA or DHCP, set as persistent, or temporarily forced.
 They can be checked through the main node map
 (Arena::IDevice::GetNodeMap, 'GevCurrentIPAddress',
 'GevCurrentSubnetMask', 'GevCurrentDefaultGateway').

 DHCP (Arena::IDevice::GetNodeMap, 'GevCurrentIPConfigurationDHCP') and
 IP persistence (Arena::IDevice::GetNodeMap,
 'GevCurrentIPConfigurationPersistentIP') can be enabled/disabled
 through the node map. If both are enabled, a device will default to
 its persistent IP settings. If neither, it will default to LLA
 (Arena::IDevice::GetNodeMap, 'GevCurrentIPConfigurationLLA'), which cannot
 be disabled.

 In order to configure a device to use a persistent IP configuration,
 not only must IP persistence be enabled (Arena::IDevice::GetNodeMap,
 'GevCurrentIPConfigurationPersistentIP'), but the IP address
 (Arena::IDevice::GetNodeMap, 'GevPersistentIPAddress'), subnet mask
 (Arena::IDevice::GetNodeMap, 'GevPersistentSubnetMask'), and default
 gateway (Arena::IDevice::GetNodeMap, 'GevPersistentDefaultGateway')
 must be set.

 Forcing an IP (Arena::IDevice::ForceIP) temporarily changes an IP
 address, subnet mask, and default gateway of a device. A forced IP
 configuration will reset on a device reboot
 (Arena::IDevice::GetNodeMap, 'DeviceReset').

 The subnet mask returned by this getter is the same as the one
 received in the GigE Vision discovery acknowledgement, but as a
 dot-separated string.

 @warning 
  - Represents the same information as Arena::DeviceInfo::SubnetMask.
  - A persistent IP may be quicker to enumerate than DHCP, which
    should be faster than LLA.

 @see 
  - Arena::IDevice::GetNodeMap
  - Arena::IDevice::ForceIP
  - Arena::DeviceInfo::SubnetMask

</member>
        <member name="M:Arena.DeviceInfo.SubnetMask">
 @fn virtual uint32_t SubnetMask()

 @return 
  - Type: uint32_t
  - Subnet mask of the device as an integer

 <B> SubnetMask </B> gets the subnet mask of a device on the network,
 returning it as its raw integer value.

 The GigE Vision specification only allows for IPv4 subnet masks. The
 subnet mask is represented by the lower 32 bits of the integer
 returned. Both <B> SubnetMask </B> and <B> SubnetMaskStr </B>
 represent the same subnet mask. Where <B> SubnetMask </B> returns the
 value in its raw integer format, <B> SubnetMaskStr </B> returns it as
 a more human-readable string:
  - <B> SubnetMask </B>: 0xFFFF0000 
  - <B> SubnetMaskStr </B>: 255.255.0.0

 A device may have its IP address, subnet mask, and default gateway
 assigned by LLA or DHCP, set as persistent, or temporarily forced.
 They can be checked through the main node map
 (Arena::IDevice::GetNodeMap, 'GevCurrentIPAddress',
 'GevCurrentSubnetMask', 'GevCurrentDefaultGateway').

 DHCP (Arena::IDevice::GetNodeMap, 'GevCurrentIPConfigurationDHCP') and
 IP persistence (Arena::IDevice::GetNodeMap,
 'GevCurrentIPConfigurationPersistentIP') can be enabled/disabled
 through the node map. If both are enabled, a device will default to
 its persistent IP settings. If neither, it will default to LLA
 (Arena::IDevice::GetNodeMap, 'GevCurrentIPConfigurationLLA'), which cannot
 be disabled.

 In order to configure a device to use a persistent IP configuration,
 not only must IP persistence be enabled (Arena::IDevice::GetNodeMap,
 'GevCurrentIPConfigurationPersistentIP'), but the IP address
 (Arena::IDevice::GetNodeMap, 'GevPersistentIPAddress'), subnet mask
 (Arena::IDevice::GetNodeMap, 'GevPersistentSubnetMask'), and default
 gateway (Arena::IDevice::GetNodeMap, 'GevPersistentDefaultGateway')
 must be set.

 Forcing an IP (Arena::IDevice::ForceIP) temporarily changes an IP
 address, subnet mask, and default gateway of a device. A forced IP
 configuration will reset on a device reboot
 (Arena::IDevice::GetNodeMap, 'DeviceReset').

 The subnet mask returned by this getter is the same as the one
 received in the GigE Vision discovery acknowledgement.

 @warning 
  - Represents the same information as Arena::DeviceInfo::SubnetMaskStr.
  - A persistent IP may be quicker to enumerate than DHCP, which
    should be faster than LLA.

 @see 
  - Arena::IDevice::GetNodeMap
  - Arena::IDevice::ForceIP
  - Arena::DeviceInfo::SubnetMaskStr

</member>
        <member name="M:Arena.DeviceInfo.IpAddressStr">
 @fn virtual GenICam::gcstring IpAddressStr()

 @return 
  - Type: GenICam::gcstring
  - IP address of the device as a string

 <B> IpAddressStr </B> gets the IP address of a device on the network,
 returning it as a string.

 The GigE Vision specification only allows for IPv4 IP addresses. Both
 <B> IpAddress </B> and <B> IpAddressStr </B> represent the same IP
 address. Where <B> IpAddress </B> returns the value in its raw integer
 format, <B> IpAddressStr </B> returns it as a more human-readable
 string:
  - <B> IpAddress </B>: 0xA9FE0101 
  - <B> IpAddressStr </B>: 169.254.1.1

 A device may have its IP address, subnet mask, and default gateway
 assigned by LLA or DHCP, set as persistent, or temporarily forced.
 They can be checked through the main node map
 (Arena::IDevice::GetNodeMap, 'GevCurrentIPAddress',
 'GevCurrentSubnetMask', 'GevCurrentDefaultGateway').

 DHCP (Arena::IDevice::GetNodeMap, 'GevCurrentIPConfigurationDHCP') and
 IP persistence (Arena::IDevice::GetNodeMap,
 'GevCurrentIPConfigurationPersistentIP') can be enabled/disabled
 through the node map. If both are enabled, a device will default to
 its persistent IP settings. If neither, it will default to LLA
 (Arena::IDevice::GetNodeMap, 'GevCurrentIPConfigurationLLA'), which cannot
 be disabled.

 In order to configure a device to use a persistent IP configuration,
 not only must IP persistence be enabled (Arena::IDevice::GetNodeMap,
 'GevCurrentIPConfigurationPersistentIP'), but the IP address
 (Arena::IDevice::GetNodeMap, 'GevPersistentIPAddress'), subnet mask
 (Arena::IDevice::GetNodeMap, 'GevPersistentSubnetMask'), and default
 gateway (Arena::IDevice::GetNodeMap, 'GevPersistentDefaultGateway')
 must be set.

 Forcing an IP (Arena::IDevice::ForceIP) temporarily changes an IP
 address, subnet mask, and default gateway of a device. A forced IP
 configuration will reset on a device reboot
 (Arena::IDevice::GetNodeMap, 'DeviceReset').

 The IP address returned by this getter is the same as the one received
 in the GigE Vision discovery acknowledgement, but as a dot-separated
 string.

 @warning 
  - Represents the same information as Arena::DeviceInfo::IpAddress.
  - A persistent IP may be quicker to enumerate than DHCP, which
    should be faster than LLA.

 @see 
  - Arena::IDevice::GetNodeMap
  - Arena::IDevice::ForceIP
  - Arena::DeviceInfo::IpAddress

</member>
        <member name="M:Arena.DeviceInfo.IpAddress">
 @fn virtual uint32_t IpAddress()

 @return 
  - Type: uint32_t
  - IP address of the device as an integer

 <B> IpAddress </B> gets the IP address of a device on the network,
 returning it as its raw integer value.

 The GigE Vision specification only allows for IPv4 IP addresses. The
 IP address is represented by the lower 32 bits of the integer
 returned. Both <B> IpAddress </B> and <B> IpAddressStr </B> represent
 the same IP address. Where <B> IpAddress </B> returns the value in its
 raw integer format, <B> IpAddressStr </B> returns it as a more
 human-readable string:
  - <B> IpAddress </B>: 0xA9FE0101 
  - <B> IpAddressStr </B>: 169.254.1.1

 A device may have its IP address, subnet mask, and default gateway
 assigned by LLA or DHCP, set as persistent, or temporarily forced.
 They can be checked through the main node map
 (Arena::IDevice::GetNodeMap, 'GevCurrentIPAddress',
 'GevCurrentSubnetMask', 'GevCurrentDefaultGateway').

 DHCP (Arena::IDevice::GetNodeMap, 'GevCurrentIPConfigurationDHCP') and
 IP persistence (Arena::IDevice::GetNodeMap,
 'GevCurrentIPConfigurationPersistentIP') can be enabled/disabled
 through the node map. If both are enabled, a device will default to
 its persistent IP settings. If neither, it will default to LLA
 (Arena::IDevice::GetNodeMap, 'GevCurrentIPConfigurationLLA'), which cannot
 be disabled.

 In order to configure a device to use a persistent IP configuration,
 not only must IP persistence be enabled (Arena::IDevice::GetNodeMap,
 'GevCurrentIPConfigurationPersistentIP'), but the IP address
 (Arena::IDevice::GetNodeMap, 'GevPersistentIPAddress'), subnet mask
 (Arena::IDevice::GetNodeMap, 'GevPersistentSubnetMask'), and default
 gateway (Arena::IDevice::GetNodeMap, 'GevPersistentDefaultGateway')
 must be set.

 Forcing an IP (Arena::IDevice::ForceIP) temporarily changes an IP
 address, subnet mask, and default gateway of a device. A forced IP
 configuration will reset on a device reboot
 (Arena::IDevice::GetNodeMap, 'DeviceReset').

 The IP address returned by this getter is the same as the one received
 in the GigE Vision discovery acknowledgement.

 @warning 
  - Represents the same information as Arena::DeviceInfo::IpAddressStr.
  - A persistent IP may be quicker to enumerate than DHCP, which
    should be faster than LLA.

 @see 
  - Arena::IDevice::GetNodeMap
  - Arena::IDevice::ForceIP
  - Arena::DeviceInfo::IpAddressStr

</member>
        <member name="M:Arena.DeviceInfo.SerialNumber">
 @fn virtual GenICam::gcstring SerialNumber()

 @return 
  - Type: GenICam::gcstring
  - Serial number of the device

 <B> SerialNumber </B> gets the serial number of a device. A serial
 number differentiates between devices. Each LUCID device has a unique
 serial number. Lucid serial numbers are numeric, but the serial
 numbers of other vendors may be alphanumeric.

 The serial number returned by this getter is the same as the one
 received in the GigE Vision discovery acknowledgement.

 @warning 
  - Serial numbers from different manufacturers may overlap

</member>
        <member name="M:Arena.DeviceInfo.VendorName">
 @fn virtual GenICam::gcstring VendorName()

 @return 
  - Type: GenICam::gcstring
  - Vendor name of the device

 <B> VendorName </B> gets the vendor/manufacturer name of a device.
 Vendor names differentiate between device vendors/manufacturers. Lucid
 devices return 'Lucid Vision Labs'.

 The vendor name returned by this getter is the same as the one
 received in the GigE Vision discovery acknowledgement.

</member>
        <member name="M:Arena.DeviceInfo.ModelName">
 @fn virtual GenICam::gcstring ModelName()

 @return 
  - Type: GenICam::gcstring
  - Model name of the device

 <B> ModelName </B> gets the model name of a device.

 Model names are used to differentiate between products. Below are a
 few examples of Lucid Vision model names:
  - PHX050S-MC
  - PHX032S-CC
  - TRI032S-MC

 The model name returned by this getter is the same as the one received
 in the GigE Vision discovery acknowledgement.

</member>
        <member name="P:ArenaNET.IDevice.TLInterfaceNodeMap">
            <summary>
GenTL transport layer interface node map
</summary>
        </member>
        <member name="P:ArenaNET.IDevice.TLStreamNodeMap">
            <summary>
GenTL transport layer stream node map
</summary>
        </member>
        <member name="P:ArenaNET.IDevice.TLDeviceNodeMap">
            <summary>
GenTL transport layer device node map
</summary>
        </member>
        <member name="P:ArenaNET.IDevice.NodeMap">
            <summary>
Node map containing a device's complete feature set
</summary>
        </member>
        <member name="M:ArenaNET.IDevice.DeregisterAllImageCallbacks">
            <summary>
Deregisters all image callbacks
</summary>
        </member>
        <member name="M:ArenaNET.IDevice.DeregisterImageCallback(ArenaNET.IDevice.del)">
            <summary>
Deregisters image callback
</summary>
            <param name="cbfunction">Image callback</param>
        </member>
        <member name="M:ArenaNET.IDevice.ResetWaitForNextLeader">
            <summary>
Resets WaitForNextLeader state
</summary>
        </member>
        <member name="M:ArenaNET.IDevice.WaitForNextLeader(System.UInt64)">
            <summary>
Waits for next leader
</summary>
            <param name="timeout">Maximum time to wait for next leader</param>
        </member>
        <member name="M:ArenaNET.IDevice.WaitOnEvent(System.UInt64)">
            <summary>
Waits on an event
</summary>
            <param name="timeout">Maximum time to wait for an event</param>
        </member>
        <member name="M:ArenaNET.IDevice.DeinitializeEvents">
            <summary>
Deinitializes the underlying events engine
</summary>
        </member>
        <member name="M:ArenaNET.IDevice.InitializeEvents">
            <summary>
Initializes the underlying events engine
</summary>
        </member>
        <member name="M:ArenaNET.IDevice.RequeueBuffer(ArenaNET.IBuffer)">
            <summary>
Requeues a buffer (IBuffer, IImage, IChunkData)
</summary>
            <param name="buffer">Buffer to requeue</param>
        </member>
        <member name="M:ArenaNET.IDevice.GetBuffer(System.UInt64)">
            <summary>
Retrieves a buffer
</summary>
            <param name="timeout">Maximum time to wait for a buffer</param>
            <returns>A buffer</returns>
        </member>
        <member name="M:ArenaNET.IDevice.GetCompressedImage(System.UInt64)">
            <summary>
Retrieves a compressed image
</summary>
            <param name="timeout">Maximum time to wait for the compressed image</param>
            <returns>A compressed image</returns>
        </member>
        <member name="M:ArenaNET.IDevice.GetImage(System.UInt64)">
            <summary>
Retrieves an image
</summary>
            <param name="timeout">Maximum time to wait for an image</param>
            <returns>An image</returns>
        </member>
        <member name="M:ArenaNET.IDevice.StopStream">
            <summary>
Stops the underlying stream engine
</summary>
        </member>
        <member name="M:ArenaNET.IDevice.StartStream(System.UInt32)">
            <summary>
Starst the underlying stream engine acquiring images with a 
specified number of buffers
</summary>
            <param name="numBuffers">...</param>
        </member>
        <member name="M:ArenaNET.IDevice.StartStream">
            <summary>
Starts the underlying stream engine acquiring images
</summary>
        </member>
        <member name="P:ArenaNET.IDevice.IsConnected">
            <summary>
Whether or not the device is connected
</summary>
        </member>
        <member name="T:ArenaNET.IDevice">
            <summary>
An interface to a device object
</summary>
        </member>
        <member name="M:ArenaNET.FeatureStream.Select(System.String)">
            <summary>
Adds a single streamable feature to the list of selected features to
stream. If called for the first time, also sets an internal 'select-all'
flag to false.
</summary>
            <param name="featureName">Name of the feature to select</param>
        </member>
        <member name="M:ArenaNET.FeatureStream.Write(System.String)">
            <summary>
Stream all selected features from a node map (INodeMap) to a file.
</summary>
            <param name="fileName">Name of the file to stream to</param>
        </member>
        <member name="M:ArenaNET.FeatureStream.Read(System.String)">
            <summary>
Streams all selected features from a file to a node map (INodeMap).
</summary>
            <param name="fileName">Name of the file to stream from</param>
        </member>
        <member name="M:ArenaNET.FeatureStream.Finalize">
            <summary>
A finalizer.
</summary>
        </member>
        <member name="M:ArenaNET.FeatureStream.Dispose">
            <summary>
A destructor.
</summary>
        </member>
        <member name="M:ArenaNET.FeatureStream.#ctor(ArenaNET.INodeMap)">
            <summary>
Constructs a feature stream object with a device's node map (INodeMap).
The node map cannot be changed later; construct additional feature stream
objects to stream to/from more node maps.
</summary>
            <param name="nodeMap">A node map</param>
        </member>
        <member name="T:ArenaNET.FeatureStream">
            <summary>
A FeatureStream object allows a device to stream features to and
from files, sharing values amongst one another.Features can be either
written from the device's node map (INodeMap) to a file or read
from a file to the node map.
</summary>
        </member>
        <member name="M:ArenaNET.Socket.ReceiveImages">
            <summary>
Receives multiple images from clients.
</summary>
            <returns>List of received images</returns>
        </member>
        <member name="M:ArenaNET.Socket.ReceiveImage">
            <summary>
Receives an image from clients.
</summary>
            <returns>image received</returns>
        </member>
        <member name="M:ArenaNET.Socket.ReceiveMessage">
            <summary>
Receives and handles text data from clients.
</summary>
            <returns>Received message as a string</returns>
        </member>
        <member name="M:ArenaNET.Socket.CloseListener">
            <summary>
Closes the listening socket and frees resources.
</summary>
        </member>
        <member name="M:ArenaNET.Socket.OpenListener(System.UInt16)">
            <summary>
Initializes a listening socket for receiving data.
</summary>
            <param name="port">Port number to bind the listening socket</param>
        </member>
        <member name="M:ArenaNET.Socket.SendImage(ArenaNET.IImage)">
            <summary>
Sends an image to the configured destination.
</summary>
            <param name="image">The image object to be sent.</param>
        </member>
        <member name="M:ArenaNET.Socket.SendCommand(System.String)">
            <summary>
Sends a command message to the configured destination.
</summary>
            <param name="message">The command message to be sent as a string.</param>
        </member>
        <member name="M:ArenaNET.Socket.AddDestination(System.UInt16)">
            <summary>
Configures the destination address and port for sending messages.
</summary>
            <param name="port">Port number of the destination</param>
        </member>
        <member name="M:ArenaNET.Socket.CloseSender">
            <summary>
Closes the sending socket and releases any allocated resources.
</summary>
        </member>
        <member name="M:ArenaNET.Socket.OpenSender">
            <summary>
Initializes the sending socket.
</summary>
        </member>
        <member name="M:ArenaNET.Socket.Finalize">
            <summary>
A finalizer.
</summary>
        </member>
        <member name="M:ArenaNET.Socket.Dispose">
            <summary>
A destructor.
</summary>
        </member>
        <member name="T:ArenaNET.Socket">
            <summary>
Provides functionality for socket communication, handling both sending and receiving of data and images.
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.DeviceVersion">
            <summary>
Device version of the device. For LUCID devices, this
is the firmware version.
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.IsLLAConfigurationEnabled">
            <summary>
Whether or not LLA is enabled
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.IsPersistentIpConfigurationEnabled">
            <summary>
Whether or not persistent IP is enabled
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.IsDHCPConfigurationEnabled">
            <summary>
Whether or not DHCP is enabled
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.UserDefinedName">
            <summary>
User-defined name; set through a created device's node map, not through its discovery information
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.MacAddressStr">
            <summary>
MAC address of the device, as a colon-separated string
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.MacAddress">
            <summary>
MAC address of the device, as an integer
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.DefaultGatewayStr">
            <summary>
Default gateway of the device, as a dot-separated string
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.DefaultGateway">
            <summary>
Default gateway of the device, as an integer
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.SubnetMaskStr">
            <summary>
Subnet mask of the device, as a dot-separated string
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.SubnetMask">
            <summary>
Subnet mask of the device, as an integer
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.IpAddressStr">
            <summary>
IP address of the device, as a dot-separated string
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.IpAddress">
            <summary>
IP address of the device, as an integer
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.SerialNumber">
            <summary>
Serial number of the device
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.VendorName">
            <summary>
Vendor name of the device
</summary>
        </member>
        <member name="P:ArenaNET.IDeviceInfo.ModelName">
            <summary>
Model name of the device
</summary>
        </member>
        <member name="T:ArenaNET.IDeviceInfo">
            <summary>
Device information objects contain device discovery information used to 
find, filter, and create devices.
</summary>
        </member>
        <member name="M:ArenaNET.ISystem.DeregisterAllDeviceDisconnectCallbacks">
            <summary>
Deregisters all device disconnect callbacks
</summary>
        </member>
        <member name="M:ArenaNET.ISystem.ForceIp(System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
Forces the device that matches the macAddress to a temporary new
ipAddress, subnetMask and defaultGateway.
</summary>
            <param name="macAddress">48 bit MAC address identifying the device to force the IP address to</param>
            <param name="ipAddress">32 bit integer representing the IP address that is meant to
be forced to the device</param>
            <param name="subnetMask">32 bit integer representing the subnetmask that is meant to
be forced to the device</param>
            <param name="defaultGateway">32 bit integer representing the gateway that is meant to
be forced to the device</param>
        </member>
        <member name="M:ArenaNET.ISystem.GetTLInterfaceNodeMap(ArenaNET.IDeviceInfo)">
            <summary>
Gets TLInterfaceParamateres nodemap from system.
</summary>
            <param name="info">Device info linked to system interface</param>
        </member>
        <member name="P:ArenaNET.ISystem.TLSystemNodeMap">
            <summary>
GenTL transport layer system node map.
</summary>
        </member>
        <member name="M:ArenaNET.ISystem.DestroyDevice(ArenaNET.IDevice)">
            <summary>
Destroys a device, cleans it up, and deallocates memory.
</summary>
            <param name="device">Device to destroy</param>
        </member>
        <member name="M:ArenaNET.ISystem.CreateDevice(ArenaNET.IDeviceInfo)">
            <summary>
Creates a device from its device information object (IDeviceInfo).
</summary>
            <param name="info">Device information object related to the device to create</param>
            <returns>A ready-to-use device</returns>
        </member>
        <member name="M:ArenaNET.ISystem.RemoveUnicastDiscoveryDevice(System.String)">
            <summary>
Unregisters an IP address for a device on a different subnet than the host so 
a unicast discovery will no longer be fired for the device when UpdateDevices()
is called.
</summary>
            <param name="remoteIpAddress">The IP address of the device</param>
        </member>
        <member name="M:ArenaNET.ISystem.AddUnicastDiscoveryDevice(System.String)">
            <summary>
Registers an IP address for a device on a different subnet than the host to 
allow it to be enumerated with UpdateDevices().
</summary>
            <param name="remoteIpAddress">The IP address of the device</param>
        </member>
        <member name="P:ArenaNET.ISystem.Interfaces">
            <summary>
List of discovered interfaces.
</summary>
        </member>
        <member name="P:ArenaNET.ISystem.Devices">
            <summary>
List of discovered devices; empty before the list is updated (UpdateDevices).
</summary>
        </member>
        <member name="M:ArenaNET.ISystem.UpdateDevices(ArenaNET.IInterfaceInfo,System.UInt64)">
            <summary>
Updates the internal list of devices (and their interfaces).
</summary>
            <param name="infaceInfo">[Optional] Interface to update</param>
            <param name="timeout">Time to wait for connected devices to respond</param>
            <returns>Whether or not changes took place to the device list since it was last updated</returns>
        </member>
        <member name="M:ArenaNET.ISystem.UpdateDevices(System.UInt64)">
            <summary>
Updates the internal list of devices (and their interfaces).
</summary>
            <param name="timeout">Time to wait for connected devices to respond</param>
            <returns>Whether or not changes took place to the device list since it was last updated</returns>
        </member>
        <member name="T:ArenaNET.ISystem">
            <summary>
The system is the entry point to the Arena SDK. It is retrieved and set up
through the static Arena class.
</summary>
        </member>
        <member name="M:ArenaNET.Arena.GetVersion">
            <summary>
Get version
</summary>
            <returns>Build version</returns>
        </member>
        <member name="M:ArenaNET.Arena.GetBitsPerPixel(System.UInt64)">
            <summary>
Gets bits per pixel
</summary>
            <param name="pixelFormat">Pixel format of an image</param>
            <returns>Number of bits per pixel</returns>
        </member>
        <member name="M:ArenaNET.Arena.CalculateMaximumNumberOfBuffers(System.UInt32)">
            <summary>
Calculates the number of buffers it would take to fill 80% of
the available memory.
</summary>
            <param name="payloadSize">Payload size of an image</param>
            <returns>Maximum number of buffers</returns>
        </member>
        <member name="M:ArenaNET.Arena.CalculateCRC32(System.Byte[])">
            <summary>
Calculates a CRC value (cyclical redundancy check) on a 
dataset. This is used to check whether the dataset has been sent
in its entirety.
</summary>
            <param name="data">An array of the data to calculate the CRC</param>
        </member>
        <member name="M:ArenaNET.Arena.CloseSystem(ArenaNET.ISystem)">
            <summary>
Cleans up the system (ISystem) and deinitializes the
Arena SDK, deallocating all memory.
</summary>
            <param name="system">The system object</param>
        </member>
        <member name="M:ArenaNET.Arena.OpenSystem">
            <summary>
Initializes the Arena SDK and retrieves the system
object(ISystem). The system must be closed, or memory will leak.
</summary>
            <returns>The system object</returns>
        </member>
        <member name="M:ArenaNET.Arena.Finalize">
            <summary>
A finalizor.
</summary>
        </member>
        <member name="M:ArenaNET.Arena.Dispose">
            <summary>
A destructor.
</summary>
        </member>
        <member name="T:ArenaNET.Arena">
            <summary>
Static Arena class provides functionality not associated to any
specific instance including opening and closing the system, 
calculating CRCs and build version
</summary>
        </member>
        <member name="P:ArenaNET.IInterfaceInfo.MacAddressStr">
            <summary>
MAC address of the interface, as a colon-separated string
</summary>
        </member>
        <member name="P:ArenaNET.IInterfaceInfo.MacAddress">
            <summary>
MAC address of the interface, as an integer
</summary>
        </member>
        <member name="P:ArenaNET.IInterfaceInfo.SubnetMaskStr">
            <summary>
Subnet mask of the interface, as a dot-separated string
</summary>
        </member>
        <member name="P:ArenaNET.IInterfaceInfo.SubnetMask">
            <summary>
Subnet mask of the interface, as an integer
</summary>
        </member>
        <member name="P:ArenaNET.IInterfaceInfo.IpAddressStr">
            <summary>
IP address of the interface, as a dot-separated string
</summary>
        </member>
        <member name="P:ArenaNET.IInterfaceInfo.IpAddress">
            <summary>
IP address of the interface, as an integer
</summary>
        </member>
        <member name="T:ArenaNET.IInterfaceInfo">
            <summary>
Interface information objects contain interface information used to 
select which interface to enumerate devices on.
</summary>
        </member>
        <member name="M:ArenaNET.ImageFactory.SplitChannels(ArenaNET.IImage)">
            <summary>
Split a multi-channel image (IImage).
</summary>
            <param name="image">Image to split</param>
            <returns>List of images (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.DeinterleaveChannelsShallow(System.Byte[],System.UInt64,ArenaNET.IImage)">
            <summary>
Scales an image (IImage).
</summary>
            <param name="image">Image to convert</param>
            <param name="data">Image data</param>
            <param name="len">Image length</param>
            <returns>Deinterleaved image (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.DecompressImage(ArenaNET.ICompressedImage)">
            <summary>
Decompresses a compressed image (ICompressedImage).
</summary>
            <param name="compressedImage">Compressed image to decompress</param>
            <returns>Decompressed image (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.DestroyCompressedImage(ArenaNET.ICompressedImage)">
            <summary>
Destroys a compressed image (ICompressedImage).
</summary>
            <param name="compressedImage">Compressed image to destroy (created, copied, and converted images must be destroyed; images retrieved from a device must not be destroyed).</param>
        </member>
        <member name="M:ArenaNET.ImageFactory.Destroy(ArenaNET.IImage)">
            <summary>
Destroys an image (IImage).
</summary>
            <param name="image">Image to destroy (created, copied, and converted images must be destroyed; images retrieved from a device must not be destroyed).</param>
        </member>
        <member name="M:ArenaNET.ImageFactory.Convert(ArenaNET.IImage,&lt;unknown type&gt;,ArenaNET.EBayerAlgorithm)">
            <summary>
Converts an image, using a particular bayer algorithm, if applicable.
</summary>
            <param name="image">Image to convert</param>
            <param name="pixelFormat">Pixel format to convert to</param>
            <param name="bayerAlgorithm">Algorithm to use for interpolating bayer data</param>
            <returns>Converted image (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.Convert(ArenaNET.IImage,&lt;unknown type&gt;)">
            <summary>
Converts an image (IImage).
</summary>
            <param name="image">Image to convert</param>
            <param name="pixelFormat">Pixel format to convert to</param>
            <returns>Converted image (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.CopyCompressedImage(ArenaNET.ICompressedImage)">
            <summary>
Copies a compressed image (ICompressedImage).
</summary>
            <param name="compressedImage">Compressed image to copy</param>
            <returns>Deep copy of the original (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.Copy(ArenaNET.IImage)">
            <summary>
Copies an image (IImage).
</summary>
            <param name="image">Image to copy</param>
            <returns>Deep copy of the original (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.Shallow(System.Byte[],System.UInt32,System.UInt32,&lt;unknown type&gt;)">
            <summary>
Creates an image using user-memory (IImage).
</summary>
            <param name="data">Image data</param>
            <param name="width">Image width</param>
            <param name="height">Image height</param>
            <param name="pixelFormat">Image pixel format</param>
            <returns>An image from user-memory (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.CreateCompressedImage(System.Byte[],&lt;unknown type&gt;)">
            <summary>
Creates a compressed image (ICompressedImage).
</summary>
            <param name="data">Compressed image data</param>
            <param name="pixelFormat">Image pixel format</param>
            <returns>A created compressed image (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.Create(System.Byte[],System.UInt32,System.UInt32,&lt;unknown type&gt;)">
            <summary>
Creates an image (IImage).
</summary>
            <param name="data">Image data</param>
            <param name="width">Image width</param>
            <param name="height">Image height</param>
            <param name="pixelFormat">Image pixel format</param>
            <returns>A created image (must be destroyed)</returns>
        </member>
        <member name="M:ArenaNET.ImageFactory.Finalize">
            <summary>
A finalizer.
</summary>
        </member>
        <member name="M:ArenaNET.ImageFactory.Dispose">
            <summary>
A destructor.
</summary>
        </member>
        <member name="T:ArenaNET.ImageFactory">
            <summary>
Static image factory for creating, copying, and converting images.
</summary>
        </member>
        <member name="M:ArenaNET.ICompressedImage.AsChunkData">
            <summary>
Casts the compressed image to a chunk data
</summary>
            <returns>Same compressed image behind a chunk data interface</returns>
        </member>
        <member name="P:ArenaNET.ICompressedImage.TimestampNs">
            <summary>
Compressed image timestamp in nanoseconds
</summary>
        </member>
        <member name="P:ArenaNET.ICompressedImage.Timestamp">
            <summary>
Compressed image timestamp in nanoseconds
</summary>
        </member>
        <member name="P:ArenaNET.ICompressedImage.PixelFormat">
            <summary>
Pixel format, as described in the PFNC (Pixel Format Naming Convention)
</summary>
        </member>
        <member name="T:ArenaNET.ICompressedImage">
            <summary>
An interface to a compressed image object, retrieved from a device.
</summary>
        </member>
        <member name="M:ArenaNET.IChunkData.AsImage">
            <summary>
Casts the image to an image
</summary>
            <returns>Same image behind an image interface</returns>
        </member>
        <member name="M:ArenaNET.IChunkData.GetChunk(System.String)">
            <summary>
A piece of data, contained in a chunk node (INode)
</summary>
            <param name="name">Name of the chunk</param>
            <returns>INode</returns>
        </member>
        <member name="T:ArenaNET.IChunkData">
            <summary>
An interface to a chunk data object
</summary>
        </member>
        <member name="P:ArenaNET.IImage.Bitmap">
            <summary>
Returns image data as a .NET bitmap object. Note that the
bitmap data is a shallow copy of the image data, and so the
the bitmap is only valid for the lifecycle of its parent image.
</summary>
        </member>
        <member name="M:ArenaNET.IImage.AsChunkData">
            <summary>
Casts the image to a chunk data
</summary>
            <returns>Same image behind a chunk data interface</returns>
        </member>
        <member name="P:ArenaNET.IImage.TimestampNs">
            <summary>
Image timestamp in nanoseconds
</summary>
        </member>
        <member name="P:ArenaNET.IImage.Timestamp">
            <summary>
Image timestamp in nanoseconds
</summary>
        </member>
        <member name="P:ArenaNET.IImage.PixelEndianness">
            <summary>
Pixel endianness
</summary>
        </member>
        <member name="P:ArenaNET.IImage.BitsPerPixel">
            <summary>
Number of bits per pixel
</summary>
        </member>
        <member name="P:ArenaNET.IImage.PixelFormat">
            <summary>
Pixel format, as described in the PFNC (Pixel Format Naming Convention)
</summary>
        </member>
        <member name="P:ArenaNET.IImage.PaddingY">
            <summary>
Padding of the image along the Y axis
</summary>
        </member>
        <member name="P:ArenaNET.IImage.PaddingX">
            <summary>
Padding of the image along the X axis
</summary>
        </member>
        <member name="P:ArenaNET.IImage.OffsetY">
            <summary>
Offset of the image along the Y axis
</summary>
        </member>
        <member name="P:ArenaNET.IImage.OffsetX">
            <summary>
Offset of the image along the X axis
</summary>
        </member>
        <member name="P:ArenaNET.IImage.Height">
            <summary>
Image height
</summary>
        </member>
        <member name="P:ArenaNET.IImage.Width">
            <summary>
Image width
</summary>
        </member>
        <member name="T:ArenaNET.IImage">
            <summary>
An interface to an image object, retrieved from a device.
</summary>
        </member>
        <member name="M:ArenaNET.IBuffer.VerifyCRC">
            <summary>
Whether or not the CRC of the data matches the CRC from the camera
</summary>
            <returns>True on match; otherwise, false</returns>
        </member>
        <member name="P:ArenaNET.IBuffer.DataIsLargerThanBuffer">
            <summary>
Whether or not the data is too large for the buffer
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.IsIncomplete">
            <summary>
Whether or not the image data is incomplete
</summary>
        </member>
        <member name="M:ArenaNET.IBuffer.AsCompressedImage">
            <summary>
Casts the buffer to a compressed image
</summary>
            <returns>Same image behind a compressed image interface</returns>
        </member>
        <member name="M:ArenaNET.IBuffer.AsChunkData">
            <summary>
Casts the buffer to a chunk data
</summary>
            <returns>Same image behind a chunk data interface</returns>
        </member>
        <member name="M:ArenaNET.IBuffer.AsImage">
            <summary>
Casts the buffer to an image
</summary>
            <returns>Same image behind an image interface</returns>
        </member>
        <member name="P:ArenaNET.IBuffer.IsCompressedImage">
            <summary>
Whether or not the buffer contains compressed image data
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.HasChunkData">
            <summary>
Whether or not the buffer contains chunk data
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.HasImageData">
            <summary>
Whether or not buffer contains image data
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.PayloadType">
            <summary>
Type of payload data
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.FrameId">
            <summary>
Frame ID of the buffer
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.SizeOfBuffer">
            <summary>
Size of the buffer to store the data
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.PayloadSize">
            <summary>
Size that the data would be if no data is missed
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.SizeFilled">
            <summary>
Size of the data, missing data not included
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.DataArray">
            <summary>
Managed copy of the image data
</summary>
        </member>
        <member name="P:ArenaNET.IBuffer.NativePtr">
            <summary>
Pointer to unmanaged image data
</summary>
        </member>
        <member name="T:ArenaNET.IBuffer">
            <summary>
A buffer object, retrieved from a device
</summary>
        </member>
        <member name="M:ArenaNET.IEnumeration.GetEntryByName(System.String)">
            <summary>
Get an Entry node by its name
</summary>
        </member>
        <member name="P:ArenaNET.IEnumeration.Entry">
            <summary>
Current entry node
</summary>
        </member>
        <member name="P:ArenaNET.IEnumeration.Symbolic">
            <summary>
Current entry node name
</summary>
        </member>
        <member name="P:ArenaNET.IEnumeration.IntValue">
            <summary>
Current entry integer value
</summary>
        </member>
        <member name="P:ArenaNET.IEnumeration.Entries">
            <summary>
Child entry nodes
</summary>
        </member>
        <member name="P:ArenaNET.IEnumeration.Symbolics">
            <summary>
Node names of all child entry nodes
</summary>
        </member>
        <member name="T:ArenaNET.IEnumeration">
            <summary>
Interface for enumeration nodes
</summary>
        </member>
        <member name="P:ArenaNET.ICategory.Features">
            <summary>
Child nodes, returned as a list of nodes with an IValue interface
</summary>
        </member>
        <member name="T:ArenaNET.ICategory">
            <summary>
Interface for category nodes
</summary>
        </member>
        <member name="M:ArenaNET.IFloat.ImposeMax(System.Double)">
            <summary>
Imposes a maximum on the value
</summary>
            <param name="value">Maximum to impose</param>
        </member>
        <member name="M:ArenaNET.IFloat.ImposeMin(System.Double)">
            <summary>
Imposes a minimum on the value
</summary>
            <param name="value">Minimum to impose</param>
        </member>
        <member name="P:ArenaNET.IFloat.DisplayPrecision">
            <summary>
Value precision
</summary>
        </member>
        <member name="P:ArenaNET.IFloat.DisplayNotation">
            <summary>
Best way to display value
</summary>
        </member>
        <member name="P:ArenaNET.IFloat.Unit">
            <summary>
Unit of the value
</summary>
        </member>
        <member name="P:ArenaNET.IFloat.Representation">
            <summary>
Best representation of the value
</summary>
        </member>
        <member name="M:ArenaNET.IFloat.GetListOfValidValues(System.Boolean)">
            <summary>
Retrieves a bounded list of valid increment values, if applicable
</summary>
            <param name="bounded">True if bounded; otherwise, false</param>
            <returns>A bounded list of values</returns>
        </member>
        <member name="M:ArenaNET.IFloat.GetListOfValidValues">
            <summary>
Retrieves a list of valid values, if applicable
</summary>
            <returns>A list of valid values</returns>
        </member>
        <member name="P:ArenaNET.IFloat.Inc">
            <summary>
The fixed increment of the node, if applicable
</summary>
        </member>
        <member name="P:ArenaNET.IFloat.IncMode">
            <summary>
The increment mode of the value
</summary>
        </member>
        <member name="P:ArenaNET.IFloat.HasInc">
            <summary>
Whether or not the node has an increment
</summary>
        </member>
        <member name="P:ArenaNET.IFloat.Max">
            <summary>
Maximum value of the node
</summary>
        </member>
        <member name="P:ArenaNET.IFloat.Min">
            <summary>
Minimum value of the node
</summary>
        </member>
        <member name="P:ArenaNET.IFloat.Value">
            <summary>
Value of the node
</summary>
        </member>
        <member name="T:ArenaNET.IFloat">
            <summary>
Interface for float nodes
</summary>
        </member>
        <member name="M:ArenaNET.IInteger.ImposeMax(System.Int64)">
            <summary>
Imposes a maximum value on the node
</summary>
            <param name="value">Maximum to impose</param>
        </member>
        <member name="M:ArenaNET.IInteger.ImposeMin(System.Int64)">
            <summary>
Imposes a minimum value on the node
</summary>
            <param name="value">Minimum to impose</param>
        </member>
        <member name="P:ArenaNET.IInteger.Unit">
            <summary>
Unit of the value
</summary>
        </member>
        <member name="P:ArenaNET.IInteger.Representation">
            <summary>
Best representation of the value
</summary>
        </member>
        <member name="M:ArenaNET.IInteger.GetListOfValidValues(System.Boolean)">
            <summary>
Retrieves a bounded list of valid values, if applicable
</summary>
            <param name="bounded">True if bounded; otherwise, false</param>
            <returns>Bounded list of valid values</returns>
        </member>
        <member name="M:ArenaNET.IInteger.GetListOfValidValues">
            <summary>
Retrieves a list of valid values, if applicable
</summary>
            <returns>List of valid values</returns>
        </member>
        <member name="P:ArenaNET.IInteger.Inc">
            <summary>
Fixed incremement of the node, if applicable
</summary>
        </member>
        <member name="P:ArenaNET.IInteger.IncMode">
            <summary>
Increment mode of the node
</summary>
        </member>
        <member name="P:ArenaNET.IInteger.Max">
            <summary>
Maximum value of the node
</summary>
        </member>
        <member name="P:ArenaNET.IInteger.Min">
            <summary>
Minimum value of the node
</summary>
        </member>
        <member name="P:ArenaNET.IInteger.Value">
            <summary>
Value of the node
</summary>
        </member>
        <member name="T:ArenaNET.IInteger">
            <summary>
Interface for integer nodes
</summary>
        </member>
        <member name="P:ArenaNET.IString.MaxLength">
            <summary>
Maximum length of the value in bytes
</summary>
        </member>
        <member name="P:ArenaNET.IString.Value">
            <summary>
Value of the node
</summary>
        </member>
        <member name="T:ArenaNET.IString">
            <summary>
Interface for string nodes
</summary>
        </member>
        <member name="P:ArenaNET.IBoolean.Value">
            <summary>
Value of the node
</summary>
        </member>
        <member name="T:ArenaNET.IBoolean">
            <summary>
Interface for boolean nodes
</summary>
        </member>
        <member name="M:ArenaNET.INodeMap.Execute(System.String)">
            <summary>
Executes a command node.
</summary>
            <param name="nodeName">Name of the node</param>
        </member>
        <member name="M:ArenaNET.INodeMap.Unlock">
            <summary>
Unlocks the node map
</summary>
        </member>
        <member name="M:ArenaNET.INodeMap.TryLock">
            <summary>
Tries to lock the node map
</summary>
            <returns>True on success; false on failure</returns>
        </member>
        <member name="M:ArenaNET.INodeMap.Lock">
            <summary>
Locks the node map
</summary>
        </member>
        <member name="M:ArenaNET.INodeMap.Poll(System.Int64)">
            <summary>
Polls the node map
</summary>
            <param name="elapsedTime">The time that has passed since the last time the node map has been polled (in milliseconds)</param>
        </member>
        <member name="P:ArenaNET.INodeMap.DeviceName">
            <summary>
Name of the device
</summary>
        </member>
        <member name="M:ArenaNET.INodeMap.InvalidateNodes">
            <summary>
Invalidates all nodes from the node map
</summary>
        </member>
        <member name="M:ArenaNET.INodeMap.GetNode(System.String)">
            <summary>
Retrieves a feature by its name
</summary>
            <param name="name">Name of the feature</param>
            <returns>Node</returns>
        </member>
        <member name="M:ArenaNET.INodeMap.GetNodes">
            <summary>
Retrieves a list of nodes
</summary>
            <returns>List of nodes</returns>
        </member>
        <member name="T:ArenaNET.INodeMap">
            <summary>
The node maps of a device contain contain its nodes/features
</summary>
        </member>
        <member name="P:ArenaNET.ICommand.IsDone">
            <summary>
Whether or not the command node has completed execution
</summary>
        </member>
        <member name="M:ArenaNET.ICommand.Execute">
            <summary>
Executes the command node
</summary>
        </member>
        <member name="T:ArenaNET.ICommand">
            <summary>
Interface for command nodes
</summary>
        </member>
        <member name="P:ArenaNET.IRegister.Address">
            <summary>
Address of the register data
</summary>
        </member>
        <member name="P:ArenaNET.IRegister.Length">
            <summary>
Length of the register data
</summary>
        </member>
        <member name="P:ArenaNET.IRegister.DataArray">
            <summary>
Register data
</summary>
        </member>
        <member name="T:ArenaNET.IRegister">
            <summary>
Interface for register nodes
</summary>
        </member>
        <member name="M:ArenaNET.ISelector.GetSelectingFeatures">
            <summary />
            <returns />
        </member>
        <member name="M:ArenaNET.ISelector.GetSelectedFeatures">
            <summary />
            <returns />
        </member>
        <member name="P:ArenaNET.ISelector.IsSelector">
            <summary />
        </member>
        <member name="T:ArenaNET.ISelector">
            <summary />
        </member>
        <member name="P:ArenaNET.IEnumEntry.IsSelfClearing">
            <summary>
Whether or not the node entry is self-clearing
</summary>
        </member>
        <member name="P:ArenaNET.IEnumEntry.NumericValue">
            <summary>
Numeric value of the enum entry as known by the device
</summary>
        </member>
        <member name="P:ArenaNET.IEnumEntry.Symbolic">
            <summary>
Name of the entry node
</summary>
        </member>
        <member name="P:ArenaNET.IEnumEntry.IntValue">
            <summary>
Integer value of the enum entry as known by the device
</summary>
        </member>
        <member name="T:ArenaNET.IEnumEntry">
            <summary>
Interface for enum entry nodes
</summary>
        </member>
        <member name="P:ArenaNET.IValue.IgnoreCache">
            <summary>
Sets whether or not to ignore the cache on get
</summary>
        </member>
        <member name="P:ArenaNET.IValue.VerifyGet">
            <summary>
Sets whether or not to verify values on get
</summary>
        </member>
        <member name="P:ArenaNET.IValue.VerifySet">
            <summary>
Sets whether or not to verify values on set
</summary>
        </member>
        <member name="P:ArenaNET.IValue.IsValueCacheValid">
            <summary>
Whether or not the value cache is valid
</summary>
        </member>
        <member name="M:ArenaNET.IValue.FromString(System.String)">
            <summary>
Sets the value of any node type as a string
</summary>
            <param name="valueString">Value to set; must be type appropriate</param>
        </member>
        <member name="M:ArenaNET.IValue.ToString">
            <summary>
Retrieves the value of the node as a string
</summary>
            <returns>The value of a feature as a node</returns>
        </member>
        <member name="P:ArenaNET.IValue.Node">
            <summary>
This feature under a generic node interface
</summary>
        </member>
        <member name="T:ArenaNET.IValue">
            <summary>
Interface that provides a generic method of getting and settings node values of different types
</summary>
        </member>
        <member name="P:ArenaNET.INode.IsFeature">
            <summary>
Whether or not the node is a feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.PrincipalInterfaceType">
            <summary>
The principal interface type of the feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.IsDeprecated">
            <summary>
Whether or not the feature is deprecated
</summary>
        </member>
        <member name="P:ArenaNET.INode.DocuUrl">
            <summary>
Documentation URL of the feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.CastAlias">
            <summary>
Cast alias of the feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.Alias">
            <summary>
Alias of the feature
</summary>
        </member>
        <member name="M:ArenaNET.INode.ImposeVisibility(ArenaNET.EVisibility)">
            <summary>
Imposes a visibility on the feature
</summary>
            <param name="imposedVisibility">...</param>
        </member>
        <member name="M:ArenaNET.INode.ImposeAccessMode(ArenaNET.EAccessMode)">
            <summary>
Imposes an access mode on the feature
</summary>
            <param name="imposedAccessMode">...</param>
        </member>
        <member name="P:ArenaNET.INode.PropertyNames">
            <summary>
Property names of the feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.IsStreamable">
            <summary>
Whether or not the feature is streamable
</summary>
        </member>
        <member name="P:ArenaNET.INode.EventId">
            <summary>
Event ID of the feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.NodeMap">
            <summary>
Node map from where the feature comes
</summary>
        </member>
        <member name="P:ArenaNET.INode.Parents">
            <summary>
Parents of the node; nodes feature depends on
</summary>
        </member>
        <member name="P:ArenaNET.INode.ChildrenLinkType">
            <summary>
Link type regarding the subset of children retrieved from the Children property
</summary>
        </member>
        <member name="P:ArenaNET.INode.Children">
            <summary>
Children of the feature; nodes dependent on feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.DeviceName">
            <summary>
Name of the device
</summary>
        </member>
        <member name="P:ArenaNET.INode.DisplayName">
            <summary>
Display name of the feature; may have whitespace
</summary>
        </member>
        <member name="P:ArenaNET.INode.Description">
            <summary>
Description of the feature (longer than the tool tip)
</summary>
        </member>
        <member name="P:ArenaNET.INode.ToolTip">
            <summary>
Tool tip for the feature (shorter than the description)
</summary>
        </member>
        <member name="P:ArenaNET.INode.PollingTime">
            <summary>
Polling time of the feature in milliseconds
</summary>
        </member>
        <member name="P:ArenaNET.INode.CachingMode">
            <summary>
Caching mode
</summary>
        </member>
        <member name="P:ArenaNET.INode.IsAccessModeCachable">
            <summary>
Whether or not the access mode of the feature is cachable
</summary>
        </member>
        <member name="P:ArenaNET.INode.IsCachable">
            <summary>
Whether or not the feature is cachable
</summary>
        </member>
        <member name="M:ArenaNET.INode.DeregisterCallback(System.IntPtr)">
            <summary>
Deregisters the node for callback
</summary>
        </member>
        <member name="M:ArenaNET.INode.RegisterCallback(ArenaNET.INode.del)">
            <summary>
Registers the node for callback
</summary>
        </member>
        <member name="M:ArenaNET.INode.InvalidateNode">
            <summary>
Invalidates the node
</summary>
        </member>
        <member name="P:ArenaNET.INode.Visibility">
            <summary>
Visibility of the feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.NameSpace">
            <summary>
Name space for the feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.FullName">
            <summary>
Fully qualified name of the feature
</summary>
        </member>
        <member name="P:ArenaNET.INode.Name">
            <summary>
Name of the feature
</summary>
        </member>
        <member name="T:ArenaNET.INode">
            <summary>
Generic node object; houses properties and methods available to all nodes
</summary>
        </member>
        <member name="P:ArenaNET.IBase.IsWritable">
            <summary>
is node writable
</summary>
        </member>
        <member name="P:ArenaNET.IBase.IsReadable">
            <summary>
is node readable
</summary>
        </member>
        <member name="P:ArenaNET.IBase.IsAvailable">
            <summary>
is node available
</summary>
        </member>
        <member name="P:ArenaNET.IBase.AccessMode">
            <summary>
The access mode
</summary>
        </member>
        <member name="T:ArenaNET.IBase">
            <summary>
Base node object
</summary>
        </member>
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.ImageFactory.SelectBitsAndScale(ArenaNET.IImage,System.UInt64,System.Double)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.ISystem.RegisterDeviceDisconnectCallback(ArenaNET.IDevice,ArenaNET.ISystem.del)'     XML   .-->
        <!-- 'M:ArenaNET.ISystem.DeregisterDeviceDisconnectCallback(ArenaNET.ISystem.del)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:ArenaNET.IDevice.RegisterImageCallback(ArenaNET.IDevice.del)'     XML   .-->
        <!-- 'M:ArenaNET.ISystem.RegisterDeviceDisconnectCallback(ArenaNET.IDevice,ArenaNET.ISystem.del)'     XML   .-->
        <!-- 'M:ArenaNET.ISystem.DeregisterDeviceDisconnectCallback(ArenaNET.ISystem.del)'     XML   .-->
        <!-- 'M:ArenaNET.IDevice.RegisterImageCallback(ArenaNET.IDevice.del)'     XML   .-->
        <!-- 'M:ArenaNET.INode.GetProperty(System.String,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.String*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'T:Arena.DeviceInfo'     XML   .-->
        <!-- 'M:Arena.DeviceInfo.#ctor(Arena.DeviceInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:Arena.DeviceInfo.op_Assign(Arena.DeviceInfo)'     XML   .-->
        <!-- 'T:Arena.InterfaceInfo'     XML   .-->
        <!-- 'M:Arena.InterfaceInfo.#ctor(Arena.InterfaceInfo!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:Arena.InterfaceInfo.op_Assign(Arena.InterfaceInfo)'     XML   .-->
        <!-- 'T:Arena.IDevice'     XML   .-->
        <!-- 'M:Arena.IDevice.GetBuffer(System.UInt64)'     XML   .-->
        <!-- 'M:Arena.IDevice.ResetWaitForNextLeader'     XML   .-->
        <!-- 'M:Arena.IDevice.InitializeEvents'     XML   .-->
        <!-- 'M:Arena.IDevice.WaitOnEvent(System.UInt64)'     XML   .-->
        <!-- 'M:Arena.IDevice.GetTLDeviceNodeMap'     XML   .-->
        <!-- 'M:Arena.IDevice.GetTLStreamNodeMap'     XML   .-->
        <!-- 'M:Arena.IDevice.GetTLInterfaceNodeMap'     XML   .-->
        <!-- 'M:Arena.IDevice.DownloadXml'     XML   .-->
        <!-- 'M:Arena.ISystem.GetInterfaces'     XML   .-->
        <!-- 'M:Arena.ISystem.GetDevices'     XML   .-->
        <!-- 'M:Arena.ISystem.GetTLInterfaceNodeMap(Arena.DeviceInfo)'     XML   .-->
        <!-- 'T:Arena.FeatureStream'     XML   .-->
        <!-- 'M:Arena.FeatureStream.Select(GenICam_3_3_LUCID.gcstring)'     XML   .-->
        <!-- 'M:Arena.FeatureStream.op_LeftShift(GenICam_3_3_LUCID.gcstring)'     XML   .-->
        <!-- 'M:Arena.EInterfaceTypeClass.FromString(GenICam_3_3_LUCID.gcstring!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,GenApi_3_3_LUCID._EInterfaceType*)'     XML   .-->
        <!-- 'M:Arena.EInterfaceTypeClass.ToString(GenICam_3_3_LUCID.gcstring*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,GenApi_3_3_LUCID._EInterfaceType)'     XML   .-->
        <!-- 'M:Arena.EIncModeClass.FromString(GenICam_3_3_LUCID.gcstring!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,GenApi_3_3_LUCID._EIncMode*)'     XML   .-->
        <!-- 'M:Arena.EIncModeClass.ToString(GenICam_3_3_LUCID.gcstring*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,GenApi_3_3_LUCID._EIncMode)'     XML   .-->
        <!-- 'M:Arena.ExecuteNode(GenApi_3_3_LUCID.INodeMap*,GenICam_3_3_LUCID.gcstring!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'     XML   .-->
        <!-- 'M:Arena.IChunkData.GetChunk(GenICam_3_3_LUCID.gcstring)'     XML   .-->
        <!-- 'M:Arena.ImageFactory.SplitChannels(Arena.IImage*)'     XML   .-->
    </members>
</doc>